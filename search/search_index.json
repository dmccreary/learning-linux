{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Learning Linux","text":""},{"location":"#welcome-to-learning-linux","title":"Welcome to Learning Linux","text":"<p>Welcome to the Learning Linux intelligent textbook.</p> <p>Please contact me on LinkedIn</p> <p>Thanks! - Dan</p>"},{"location":"about/","title":"About the Learning Linux Book","text":"<p>TL;DR - Linux knowledge can still be a critical part of careers in the age of AI.</p> <p></p> <p>I started working at Bell Labs in 1983 as a CMOS chip designer. Although I was right out of grad school, I was already a proficient C programmer. This was somewhat unique in 1983. I worked at the Bell Labs Allentown facility where they designed and built digital signal processors installed in telephone switching equipment. I was one of the first people hired in Allentown who could write code. Within 18 months, I had written C programs that saved their drafting staff thousands of hours of time manually laying out repetitive chip masks.</p>"},{"location":"about/#kr","title":"K&amp;R","text":"<p>I was fortunate to lead efforts to move from fixed placement design to symbolic design, where chip designers just specified the high-level topology of a circuit and let design automation tools handle the rest. The person I chose to work with was none other than the famous Brian Kernighan. Brian is the \"K\" in the famous \"K&amp;R\" book, which became one of the most popular programming books of all time.</p> <p></p> <p>Brian suggested I work with him on a custom version of awk to generate symbolic layout for integrated circuits. This new language, called <code>awk-i</code>, became a central tool for our chip designers. I wrote hundreds of UNIX shell scripts that automated many parts of the process of designing, simulating, and generating all the layers of polygons used to create the masks used to build the chips. The productivity gains were dramatic. And to put this all into context, my shell scripts ran on a VAX 11/780 with a total of 2 megabytes of RAM.</p> <p>Although I was lucky to be taught UNIX by the masters, another fortunate aspect was that almost every job I had in my career of nearly 40 years involved using UNIX and Linux. I can honestly say that knowing my way around the shell was key to advancing my career at every stage.</p>"},{"location":"about/#linux-and-shell-in-the-age-of-ai","title":"Linux and Shell in the Age of AI","text":"<p>When ChatGPT came out in November of 2022, I knew that the world of coding would change forever. I thought that knowing Linux and shell coding might no longer be needed. But I was wrong. In March of 2025, Anthropic announced the revolutionary Claude Code. Here was the catch: Claude Code was built entirely around running shell commands! Every create, copy, and move was a shell command. When you watch Claude Code work, you are watching a series of shell commands running on your local computer.</p> <p>What I can also tell you is that competing operating systems like Windows increasingly must support Linux through tools like the Windows Subsystem for Linux. Tools like Claude Code have a much harder time working with obscure variations of command-line interfaces such as <code>PowerShell</code>, which only runs on Windows. Today, over 95% of servers in the datacenter run Linux, not Windows. If you want your tools to run everywhere, the Linux shell is really the only realistic option.</p>"},{"location":"about/#linux-continues-to-evolve","title":"Linux Continues to Evolve","text":"<p>Today, if you follow the hundreds of thousands of people who contribute to the Linux code base and its related tools, you see that it is not a static operating system. Many younger Rust developers are realizing that running Linux on 128 cores is a lot more complicated than the original VAX 11/780 with a single CPU that I worked on back in 1983.</p> <p>How Linux will be built a few years from now is difficult to predict. But what I can tell you is that knowing what the <code>ls</code>, <code>cp</code>, and <code>mv</code> commands do will be with us for a long time! It is my sincere hope that this becomes the best intelligent textbook to help you on your journey to becoming a Linux master.</p> <p>Best of luck to you in your career!</p> <p>Dan McCreary - LinkedIn December 2025</p>"},{"location":"contact/","title":"Contact","text":"<p>Please contact me on LinkedIn</p> <p>Thanks! - Dan</p>"},{"location":"course-description/","title":"Learning Linux Course Description","text":"<p>Title: Learning Linux Length: 15-week semester long course Audience: High school students Course Description Quality Score: 91/100 (Excellent)</p>"},{"location":"course-description/#prerequisites","title":"Prerequisites","text":"<ul> <li>Students must have strong typing skills including the use of the copy/cut and paste commands.</li> <li>Students should have access to a Linux terminal shell.  Any of the following is acceptable:<ul> <li>Mac Terminal</li> <li>Windows Windows System for Linux (WSL)</li> <li>Chromebook in developer mode</li> <li>Raspberry Pi (available in classrooms for under $100/student without a monitor) See here for details.</li> </ul> </li> </ul>"},{"location":"course-description/#why-this-course","title":"Why This Course","text":"<p>In late September 2025 The Raspberry Pi Foundation announced the Raspberry Pi 500+. Although this is just one announcement in a long line of Raspberry Pi products, the features and performance of the 500+ was stunning.  But this was not just for the Do-It-Yourself (DIY) crowd.  This was a device that could compete with some of the best desktop computers. And the nice thing about the 500+ was that it had all the hardware ports for connecting it to thousands of sensors and motors to control lab equipment in schools.</p> <p>However, the 500+ lacked one big component: A really fun book to teach kids how to use the powerful Linux operating system that powered the 500+.</p> <p>To put this in context, this was just around the time that Anthropic Claude Code Skills were taking off.  And Claude Code was build around what core skill?  If you guess Linux shell commands you were RIGHT!.  In summary, I realized we could combine the need for Linux education with Claude Code to build a really fun world-class textbook targeting high-school students that would empower them with the knowledge they need to use these powerful tools.</p>"},{"location":"course-description/#why-this-course-is-different","title":"Why this Course is Different","text":"<p>If you do a Google Search, you can find hundreds of books on UNIX and Linux going back to the 1980s. But many of them are static printed books that are not designed for our TikTok obsessed youth that have the attention span of a gnat.  They need fun, engaging and interactive systems that can keep their attention and intelligent textbook interaction points that allow instructors to monitor their progress.</p>"},{"location":"course-description/#topics-covered","title":"Topics Covered","text":"<ul> <li>UNIX</li> <li>UNIX and C</li> <li>Portability</li> <li>Linux</li> <li>Shell</li> <li>Startup</li> <li>Dot files</li> <li>.bashrc</li> <li>.zshrc</li> <li>Shortcuts</li> <li>tab completion</li> <li>Fonts and appearance</li> <li>Terminal Size</li> <li>Automating Startup</li> <li>Shell Commands</li> <li>Shell Programs</li> <li>Command Options</li> <li>grep</li> <li>regular expressions</li> <li>The Shell Pipe</li> <li>Input</li> <li>Output</li> <li>wc</li> <li>sort</li> <li>JSON</li> <li>jc</li> <li>Markdown</li> <li>network</li> <li>ping</li> <li>traceroute</li> <li>wifi</li> <li>curl</li> <li>wget</li> <li>version info</li> <li>shutdown</li> <li>text editing</li> <li>nano</li> <li>vi and vim</li> <li>find</li> <li>locate</li> <li>awk</li> <li>sed</li> <li>compression</li> <li>tar</li> <li>zip</li> <li>gzip</li> <li>diff</li> <li>cron</li> <li>history</li> <li>Design Philosophy</li> <li>Small Modular Tools</li> <li>Basic Commands</li> <li>Navigation</li> <li>Home Directory</li> <li>Environment Variables</li> <li>Ownership</li> <li>Permissions</li> <li>Directories</li> <li>File Systems</li> <li>Mounting Devices</li> <li>USB Drives</li> <li>USB Ports</li> <li>PATH</li> <li>PATH Order</li> <li>Override</li> <li>Alias</li> <li>Whereis</li> <li>Which</li> <li>Processes</li> <li>ps</li> <li>kill</li> <li>Debugging</li> <li>Installing</li> <li>Updates</li> <li>apt</li> <li>brew</li> <li>SSH</li> <li>remote login</li> <li>Firewalls</li> <li>sudo</li> <li>Shell prompts</li> <li>Customizing Terminal</li> <li>Terminal Themes</li> <li>Terminal in VSCode</li> <li>Terminal in Thonny</li> <li>Desktops</li> <li>Linux Versions</li> <li>Debian</li> <li>Real Time</li> <li>Ubuntu</li> <li>UNIX System V</li> <li>Berkley Distribution</li> <li>BSD Releases</li> <li>Virtual Memory</li> <li>Tuning UNIX</li> <li>Flash Drives</li> <li>Swap Drives</li> <li>top</li> <li>measuring performance</li> <li>CPU benchmarks</li> <li>Disk benchmarks</li> <li>GPU</li> <li>GPU benchmarks</li> <li>Adding a GPU to the Pi</li> <li>GPU drivers</li> <li>Webcams</li> <li>Adding a camera to a Pi</li> <li>Bluetooth</li> <li>printers</li> <li>displays</li> <li>HDMI ports</li> <li>Pi HDMI Micro Port</li> <li>Multiple Displays</li> <li>Display RAM</li> <li>Sounds</li> <li>Easter Eggs</li> <li>NVIDIA drivers on Pi</li> <li>Low Cost Linux</li> <li>Raspberry Pi Zero</li> <li>Linux in STEP</li> <li>Linux in Maker Spaces</li> <li>40-pin port on the Pi</li> <li>Voltage Pins</li> <li>External Power</li> <li>Data Pins</li> <li>Monitoring Current</li> <li>LED Strip</li> <li>Motors</li> <li>Servos</li> <li>IoT</li> <li>Linux at Home</li> <li>Monitoring Your Home</li> <li>Docker</li> <li>Spinning up Linux on the Cloud</li> <li>Terraform</li> <li>Python</li> <li>PIP</li> <li>Python VMs</li> <li>Secrets</li> <li>GitHub</li> <li>git clone</li> <li>C</li> <li>The Future of Linux</li> <li>C vs. RUST</li> <li>Final Projects</li> <li>Web server</li> <li>Game Server</li> <li>Media Server</li> <li>Ad Blocker</li> <li>Retro Gaming</li> <li>VPN Setup</li> <li>VSCode</li> <li>Linux Careers</li> <li>Network admin</li> <li>Linux in Space</li> <li>Linux in Cars</li> </ul>"},{"location":"course-description/#topics-not-covered","title":"Topics Not Covered","text":"<ul> <li>Linux Internals</li> <li>Compiling Linux</li> <li>Device Drivers</li> <li>Linux Research</li> <li>Advanced RUST</li> <li>Advanced C</li> </ul>"},{"location":"course-description/#learning-objectives","title":"Learning Objectives","text":"<p>The following learning objectives are classified according to Bloom's Revised Taxonomy (Anderson and Krathwohl, 2001), organized from lower-order to higher-order cognitive skills.</p>"},{"location":"course-description/#remember","title":"Remember","text":"<p>By the end of this course, students will be able to:</p> <ol> <li>Recall the historical origins of UNIX and its relationship to the C programming language</li> <li>List common Linux shell commands (ls, cd, pwd, cp, mv, rm, mkdir, cat, grep, chmod)</li> <li>Identify the components of the Linux file system hierarchy</li> <li>Recognize the purpose of environment variables such as PATH and HOME</li> <li>Name the major Linux distributions (Debian, Ubuntu, BSD variants)</li> </ol>"},{"location":"course-description/#understand","title":"Understand","text":"<p>By the end of this course, students will be able to:</p> <ol> <li>Explain the UNIX design philosophy of small, modular tools</li> <li>Describe how the shell pipe connects command input and output</li> <li>Summarize the difference between file ownership and permissions</li> <li>Interpret file permission notation (rwx, numeric modes)</li> <li>Explain the purpose of package managers (apt, brew) in system maintenance</li> <li>Describe the role of processes and how they are managed in Linux</li> </ol>"},{"location":"course-description/#apply","title":"Apply","text":"<p>By the end of this course, students will be able to:</p> <ol> <li>Navigate the Linux file system using command-line tools</li> <li>Execute shell commands with appropriate options and arguments</li> <li>Set and modify environment variables and aliases</li> <li>Install, update, and remove software using package managers</li> <li>Mount and unmount USB drives and external storage devices</li> <li>Use process management commands (ps, top, kill) to monitor and control running programs</li> <li>Clone repositories from GitHub using git commands</li> </ol>"},{"location":"course-description/#analyze","title":"Analyze","text":"<p>By the end of this course, students will be able to:</p> <ol> <li>Diagnose permission errors and determine appropriate solutions</li> <li>Analyze system performance using benchmarking tools (CPU, disk, GPU)</li> <li>Compare different Linux distributions and their use cases</li> <li>Interpret system resource usage from tools like top</li> <li>Troubleshoot PATH-related issues when commands are not found</li> <li>Examine the differences between C and Rust for systems programming</li> </ol>"},{"location":"course-description/#evaluate","title":"Evaluate","text":"<p>By the end of this course, students will be able to:</p> <ol> <li>Assess appropriate permission settings for security and functionality</li> <li>Evaluate which Linux distribution is suitable for a given application</li> <li>Judge the trade-offs between different hardware configurations (Pi Zero vs Pi 500+)</li> <li>Critique shell scripts for efficiency and best practices</li> <li>Assess system performance bottlenecks and recommend improvements</li> </ol>"},{"location":"course-description/#create","title":"Create","text":"<p>By the end of this course, students will be able to:</p> <ol> <li>Write shell scripts that automate repetitive tasks</li> <li>Design a home monitoring system using IoT sensors and a Raspberry Pi</li> <li>Construct a development environment with Python, virtual environments, and version control</li> <li>Build Docker containers to deploy Linux applications</li> <li>Develop projects that interface with the Raspberry Pi GPIO pins (LEDs, motors, servos)</li> <li>Compose infrastructure-as-code configurations using Terraform for cloud Linux instances</li> </ol>"},{"location":"glossary/","title":"Glossary of Terms for Learning Linus","text":""},{"location":"glossary/#intelligent-textbook","title":"Intelligent Textbook","text":"<p>An adaptive learning system that dynamically adjusts content based on individual learner performance.</p> <p>See Intelligent Textbook in our supplementary material.</p>"},{"location":"license/","title":"Creative Commons License","text":"<p>All content in this repository is governed by the following license agreement:</p>"},{"location":"license/#license-type","title":"License Type","text":"<p>Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0 DEED)</p>"},{"location":"license/#link-to-license-agreement","title":"Link to License Agreement","text":"<p>https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en</p>"},{"location":"license/#your-rights","title":"Your Rights","text":"<p>You are free to:</p> <ul> <li>Share \u2014 copy and redistribute the material in any medium or format</li> <li>Adapt \u2014 remix, transform, and build upon the material</li> </ul> <p>The licensor cannot revoke these freedoms as long as you follow the license terms.</p>"},{"location":"license/#restrictions","title":"Restrictions","text":"<ul> <li>Attribution \u2014 You must give appropriate credit, provide a link to the license, and indicate if changes were made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use.</li> <li>NonCommercial \u2014 You may not use the material for commercial purposes.</li> <li>ShareAlike \u2014 If you remix, transform, or build upon the material, you must distribute your contributions under the same license as the original.</li> <li>No additional restrictions \u2014 You may not apply legal terms or technological measures that legally restrict others from doing anything the license permits.</li> </ul> <p>Notices</p> <p>You do not have to comply with the license for elements of the material in the public domain or where your use is permitted by an applicable exception or limitation.</p> <p>No warranties are given. The license may not give you all of the permissions necessary for your intended use. For example, other rights such as publicity, privacy, or moral rights may limit how you use the material.</p> <p>This deed highlights only some of the key features and terms of the actual license. It is not a license and has no legal value. You should carefully review all of the terms and conditions of the actual license before using the licensed material.</p>"},{"location":"license/#commercial-licensing","title":"Commercial Licensing","text":"<p>Commercial rights are reserved by the copyright holder. For commercial licensing, publication inquiries, or permission to use this work in commercial contexts, please contact Dan McCreary on LinkedIn.</p>"},{"location":"chapters/","title":"Chapters","text":"<p>This textbook is organized into 26 chapters covering 550 concepts across Linux fundamentals, from UNIX history to career pathways.</p>"},{"location":"chapters/#chapter-overview","title":"Chapter Overview","text":"<ol> <li>Introduction to Operating Systems and UNIX History - Origins of UNIX, key figures, and the evolution to Linux</li> <li>Getting Started with the Terminal - Shell, terminal emulator, and command line basics</li> <li>Basic Shell Commands and Help Systems - Man pages, help systems, and shell utilities</li> <li>File System Fundamentals - Linux file hierarchy, paths, and navigation</li> <li>File Operations and Manipulation - Creating, copying, moving, and viewing files</li> <li>Advanced File Operations - Wildcards, globbing, links, and file attributes</li> <li>File Permissions and Ownership - Permission system, chmod, chown, and sudo</li> <li>Text Processing with Grep and Regular Expressions - Pattern matching and text search</li> <li>Advanced Text Processing: Sed, Awk, and Pipes - Stream editing and pipeline commands</li> <li>Text Editors: Nano and Vim - Terminal-based text editing</li> <li>Shell Configuration and Environment - Dotfiles, environment variables, and aliases</li> <li>Process Management and Job Control - Processes, PIDs, and monitoring tools</li> <li>Shell Scripting and Automation - Writing scripts and scheduling with cron</li> <li>Package Management - APT, Homebrew, and software installation</li> <li>Networking Fundamentals - IP, DNS, and network diagnostics</li> <li>SSH and Remote Access - Secure shell, keys, and firewalls</li> <li>Compression, Archives, and File Search - Tar, gzip, find, and locate</li> <li>Storage Devices and System Performance - Disks, mounting, and performance monitoring</li> <li>Introduction to Raspberry Pi - Pi models, setup, and hardware interfaces</li> <li>GPIO Programming and Hardware Projects - LEDs, sensors, motors, and IoT</li> <li>Cloud Computing and Containers - Docker, cloud instances, and Terraform</li> <li>Development Tools and Version Control - Git, GitHub, Python, and IDEs</li> <li>System Administration Essentials - User management, services, and system configuration</li> <li>Terminal Customization and Fun - Custom prompts, colors, and easter eggs</li> <li>Capstone Projects - Web servers, game servers, and hands-on projects</li> <li>Linux Careers and the Future - Career paths, certifications, and future trends</li> </ol>"},{"location":"chapters/#how-to-use-this-textbook","title":"How to Use This Textbook","text":"<p>This textbook follows a carefully designed learning progression where each chapter builds on concepts from previous chapters. The learning graph ensures that prerequisites are covered before advanced topics are introduced.</p> <ul> <li>Beginners: Start with Chapter 1 and progress sequentially</li> <li>Intermediate users: Review the concept list in each chapter to find your starting point</li> <li>Raspberry Pi focus: After completing Chapters 1-18, jump to Chapters 19-20 for hardware projects</li> <li>Career preparation: Complete all chapters, with emphasis on Chapters 21-26 for modern skills</li> </ul> <p>Note: Each chapter includes a list of concepts covered. The concepts are derived from a learning graph with 550 nodes ensuring proper prerequisite sequencing.</p>"},{"location":"chapters/01-unix-history/","title":"Introduction to Operating Systems and UNIX History","text":""},{"location":"chapters/01-unix-history/#summary","title":"Summary","text":"<p>This chapter explores the fascinating origins of UNIX and Linux, tracing the journey from Bell Labs in the 1970s to the modern Linux ecosystem. You'll learn about the key figures who shaped computing history\u2014Ken Thompson, Dennis Ritchie, Richard Stallman, and Linus Torvalds\u2014and understand the UNIX philosophy that continues to influence software design today. By the end of this chapter, you'll appreciate why Linux powers everything from smartphones to supercomputers.</p>"},{"location":"chapters/01-unix-history/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 20 concepts from the learning graph:</p> <ol> <li>Operating System</li> <li>UNIX History</li> <li>Bell Labs</li> <li>Ken Thompson</li> <li>Dennis Ritchie</li> <li>C Programming Language</li> <li>UNIX Philosophy</li> <li>Small Modular Tools</li> <li>Portability</li> <li>Open Source</li> <li>GNU Project</li> <li>Richard Stallman</li> <li>Linux Kernel</li> <li>Linus Torvalds</li> <li>Linux Distributions</li> <li>Debian</li> <li>Ubuntu</li> <li>BSD Unix</li> <li>UNIX System V</li> <li>POSIX Standards</li> </ol>"},{"location":"chapters/01-unix-history/#prerequisites","title":"Prerequisites","text":"<p>This chapter assumes only the prerequisites listed in the course description. No prior Linux experience is required.</p>"},{"location":"chapters/01-unix-history/#what-even-is-an-operating-system","title":"What Even IS an Operating System?","text":"<p>Before we dive into the wild story of UNIX and Linux (spoiler alert: it involves a video game, a Finnish college student, and a lot of very angry corporate lawyers), let's talk about what an operating system actually is. Don't worry\u2014this won't be boring. I promise.</p> <p>Imagine your computer is a restaurant. You've got the kitchen (the hardware\u2014CPU, memory, hard drive), the customers (your apps and programs), and complete chaos trying to happen simultaneously. The operating system (or OS) is basically the restaurant manager who keeps everything from catching fire.</p> <p>The OS does a few critical jobs:</p> <ul> <li>Manages memory \u2013 Makes sure Chrome doesn't hog ALL your RAM (okay, it still does, but at least the OS tries)</li> <li>Handles files \u2013 Keeps track of where everything is stored so you don't lose your homework</li> <li>Runs programs \u2013 Coordinates who gets to use the CPU and when</li> <li>Talks to hardware \u2013 Translates between your apps and weird things like printers and USB drives</li> </ul> <p>Without an operating system, your computer would just be an expensive paperweight with blinking lights. And that would be sad.</p> What You Want to Do What the OS Does Behind the Scenes Open a game Loads game files from storage into memory, allocates CPU time Save a document Finds free space on disk, writes data, updates file system Connect to WiFi Manages network hardware, handles security protocols Print something Communicates with printer drivers, manages print queue <p>Now, there are lots of operating systems out there\u2014Windows, macOS, ChromeOS\u2014but today we're going to focus on the granddaddy of them all: UNIX, and its incredibly successful offspring, Linux.</p>"},{"location":"chapters/01-unix-history/#the-birth-of-unix-a-love-story-with-computers","title":"The Birth of UNIX: A Love Story (With Computers)","text":"<p>Our story begins in the late 1960s at a magical place called Bell Labs in Murray Hill, New Jersey. Bell Labs was basically the Hogwarts of technology\u2014researchers there invented transistors, lasers, information theory, and yes, UNIX. If you wanted to work on cool stuff that would change the world, Bell Labs was THE place to be.</p> <p>Fun Fact</p> <p>Bell Labs scientists have won 9 Nobel Prizes! That's more than most entire countries.</p> <p>In 1969, two brilliant programmers named Ken Thompson and Dennis Ritchie were feeling grumpy. They had been working on a project called Multics (a complicated operating system that was... well, complicated), and it wasn't going well. The project got cancelled, and Ken was especially bummed because he'd been playing a video game called \"Space Travel\" on the Multics system, and now he had nowhere to play it!</p> <p>So what did Ken do? He found an old PDP-7 computer that nobody was using, and over the course of about a month, he wrote an entirely new operating system so he could play his video game. That operating system would become UNIX.</p> <p>Yes, you read that right. One of the most important pieces of software in human history was created partly because a guy wanted to play a video game. Never let anyone tell you that gaming isn't productive!</p>"},{"location":"chapters/01-unix-history/#diagram-unix-family-tree","title":"Diagram: UNIX Family Tree","text":"<pre><code>&lt;summary&gt;UNIX Family Tree&lt;/summary&gt;\nType: timeline\n\nBloom Taxonomy: Remember, Understand\nLearning Objective: Help students visualize how UNIX evolved into different branches over time, including BSD and System V, and how Linux emerged as a separate but compatible system.\n\nTime period: 1969-2025\n\nOrientation: Vertical tree structure flowing downward\n\nEvents/Nodes:\n- 1969: Original UNIX (Ken Thompson &amp; Dennis Ritchie at Bell Labs)\n    - Branch left \u2192 BSD Unix (1977, UC Berkeley)\n        - FreeBSD (1993)\n        - NetBSD (1993)\n        - OpenBSD (1995)\n        - macOS/Darwin (2000)\n    - Branch right \u2192 UNIX System V (1983, AT&amp;T)\n        - Solaris (Sun Microsystems)\n        - AIX (IBM)\n        - HP-UX (HP)\n- 1983: GNU Project Started (Richard Stallman)\n- 1991: Linux Kernel (Linus Torvalds) + GNU = Complete OS\n    - Debian (1993)\n    - Red Hat (1994)\n    - Ubuntu (2004)\n    - Android (2008, Linux-based)\n\nColor coding:\n- Blue: Original UNIX lineage\n- Purple: BSD variants\n- Red: Commercial UNIX (System V)\n- Green: GNU/Linux ecosystem\n\nInteractive features:\n- Hover over each node to see key features\n- Click to see more details about that version\n\nImplementation: vis-network or HTML/CSS/SVG timeline\n</code></pre>"},{"location":"chapters/01-unix-history/#the-dynamic-duo-ken-and-dennis","title":"The Dynamic Duo: Ken and Dennis","text":"<p>Ken Thompson was a coding wizard who could make computers do backflips. He had a talent for making complicated things simple\u2014a skill that would become central to UNIX's design. Ken would later co-invent the Go programming language (used by Google) and UTF-8 encoding (the thing that lets you use emoji \ud83c\udf89 in text messages).</p> <p>Dennis Ritchie was the quieter of the two, but his contributions were absolutely massive. While Ken created UNIX, Dennis created something that would make UNIX\u2014and eventually almost ALL software\u2014possible: the C programming language.</p> <p>Before C, most operating systems were written in \"assembly language,\" which is basically writing instructions directly for the computer's brain. It works, but it's like giving someone directions by saying \"rotate your left leg 47 degrees, shift weight to right foot, rotate right leg...\" instead of just saying \"walk forward.\" Assembly code was specific to each type of computer, which meant if you wanted your program to run on a different machine, you basically had to rewrite the whole thing.</p> <p>C changed everything.</p>"},{"location":"chapters/01-unix-history/#c-the-programming-language-that-changed-everything","title":"C: The Programming Language That Changed Everything","text":"<p>The C programming language (created by Dennis Ritchie around 1972) was a game-changer because it was:</p> <ul> <li>High-level enough to be readable by humans (unlike assembly)</li> <li>Low-level enough to do powerful system stuff (unlike most languages at the time)</li> <li>Portable \u2013 meaning code could be moved between different computers!</li> </ul> <p>This last point\u2014portability\u2014was huge. Thompson and Ritchie rewrote UNIX in C, and suddenly UNIX could run on different types of computers without being completely rewritten each time. This was like inventing a recipe that works in ANY kitchen, not just one specific oven.</p> <pre><code>// The most famous C program ever - \"Hello, World!\"\n#include &lt;stdio.h&gt;\n\nint main() {\n    printf(\"Hello, World!\\n\");\n    return 0;\n}\n</code></pre> <p>The book that taught everyone C, written by Brian Kernighan and Dennis Ritchie (known as \"K&amp;R\"), became one of the most influential programming books ever written. If programming books had a Hall of Fame, K&amp;R would have its own wing.</p> <p>Why Does This Matter Today?</p> <p>The C language is STILL used everywhere. The Linux kernel? Written in C. Windows? Mostly C. Your phone's operating system? C and its descendants. Even Python\u2014the beginner-friendly language you might have used\u2014is written in C! Learning where C came from helps you understand why software works the way it does.</p>"},{"location":"chapters/01-unix-history/#the-unix-philosophy-do-one-thing-well","title":"The UNIX Philosophy: Do One Thing Well","text":"<p>As Thompson, Ritchie, and their colleagues developed UNIX, they established a way of thinking about software that still influences how we write programs today. This is called the UNIX Philosophy, and it can be summed up in a few key principles:</p> <ol> <li>Do one thing and do it well \u2013 Each program should focus on a single task and do it excellently</li> <li>Work together \u2013 Programs should be designed to work with other programs</li> <li>Text is universal \u2013 Use text as the common format for data (not weird proprietary formats)</li> <li>Small modular tools \u2013 Build small, sharp tools rather than giant Swiss Army knife programs</li> </ol> <p>Think about it like LEGO bricks versus a pre-built toy. With LEGO, you can combine simple pieces to build anything. With a pre-built toy, you're stuck with whatever the manufacturer decided. UNIX tools are like LEGO bricks\u2014you can combine them in creative ways to solve problems the original creators never imagined.</p> Traditional Approach UNIX Philosophy One giant program that does everything Many small programs that do one thing Complex and hard to modify Simple and easy to combine \"Here's what you can do\" \"Here are building blocks\u2014go wild!\" Like a Swiss Army knife Like a toolbox full of specialized tools <p>Here's a real example: Let's say you want to find all the large files on your computer and sort them by size. In UNIX/Linux, you can chain together small modular tools:</p> <pre><code>find /home -type f -size +100M | xargs ls -lh | sort -k5 -h\n</code></pre> <p>This command: - <code>find</code> \u2013 locates files bigger than 100MB - <code>xargs ls -lh</code> \u2013 lists them with human-readable sizes - <code>sort -k5 -h</code> \u2013 sorts by the size column</p> <p>Three simple tools, piped together, solving a complex problem. Beautiful!</p>"},{"location":"chapters/01-unix-history/#diagram-unix-philosophy-in-action","title":"Diagram: UNIX Philosophy in Action","text":"<pre><code>&lt;summary&gt;UNIX Philosophy in Action - Pipe Example&lt;/summary&gt;\nType: diagram\n\nBloom Taxonomy: Understand, Apply\nLearning Objective: Visualize how small UNIX tools connect together via pipes to accomplish complex tasks, demonstrating the \"do one thing well\" philosophy.\n\nComponents to show:\n- Three colored boxes representing commands: find (blue), xargs/ls (green), sort (orange)\n- Pipe symbols (|) connecting the boxes\n- Data flowing between boxes shown as document icons\n- Input (file system) on the left\n- Output (sorted list) on the right\n\nLayout: Horizontal flow diagram, left to right\n\nLabels:\n- Above each box: Command name and brief description\n- On pipes: \"text stream\"\n- Input label: \"File System\"\n- Output label: \"Sorted Results\"\n\nAnnotations:\n- Callout bubble: \"Each tool does ONE job perfectly\"\n- Callout bubble: \"Text flows between tools\"\n\nStyle: Clean, modern infographic style with rounded corners\nColor scheme: Blue, green, orange boxes on light background\n\nImplementation: HTML/CSS or p5.js\n</code></pre>"},{"location":"chapters/01-unix-history/#unix-spreads-system-v-and-bsd","title":"UNIX Spreads: System V and BSD","text":"<p>Throughout the 1970s, UNIX spread like wildfire through universities and research labs. AT&amp;T (the company that owned Bell Labs) had regulations that prevented them from selling software, so they basically gave UNIX away to universities for educational purposes. Students learned UNIX, loved UNIX, and then went out into the world wanting to use UNIX.</p> <p>This led to two major branches of UNIX that still influence computing today:</p>"},{"location":"chapters/01-unix-history/#unix-system-v","title":"UNIX System V","text":"<p>In 1983, AT&amp;T's rules changed and they could finally sell UNIX commercially. They released UNIX System V (pronounced \"System Five\"), which became the \"official\" commercial version of UNIX. Many big companies created their own versions based on System V, including:</p> <ul> <li>Solaris (Sun Microsystems)</li> <li>AIX (IBM)</li> <li>HP-UX (Hewlett-Packard)</li> </ul> <p>System V was the corporate, buttoned-up version of UNIX\u2014stable, supported, and expensive.</p>"},{"location":"chapters/01-unix-history/#bsd-unix-the-college-rebels","title":"BSD Unix: The College Rebels","text":"<p>Meanwhile, at the University of California, Berkeley, students and researchers had been making their own modifications and improvements to UNIX. They called their version BSD (Berkeley Software Distribution). BSD introduced many innovations that we still use today:</p> <ul> <li>The <code>vi</code> text editor (which you'll learn to either love or... have opinions about)</li> <li>The TCP/IP networking stack (literally how the internet works!)</li> <li>The C shell (csh), a popular command-line interface</li> </ul> <p>BSD was the rebellious, innovative, academic side of the UNIX family. It eventually spawned:</p> <ul> <li>FreeBSD \u2013 powers Netflix's streaming infrastructure!</li> <li>NetBSD \u2013 runs on everything from toasters to supercomputers</li> <li>OpenBSD \u2013 famous for security</li> <li>macOS \u2013 Yes! Apple's operating system is BSD-based!</li> </ul> <p>Wait, macOS is UNIX?</p> <p>Yep! Next time you open Terminal on a Mac, you're using a UNIX system. Apple built macOS on top of BSD UNIX (specifically a version called Darwin). So if you've ever used a Mac, congratulations\u2014you've already used UNIX!</p>"},{"location":"chapters/01-unix-history/#the-free-software-revolution-enter-richard-stallman","title":"The Free Software Revolution: Enter Richard Stallman","text":"<p>By the early 1980s, UNIX was everywhere in universities and corporations. But there was a problem: it wasn't free. As in, you couldn't share it, modify it, or see how it worked unless you paid AT&amp;T a lot of money.</p> <p>This annoyed a brilliant programmer at MIT named Richard Stallman (often called \"RMS\"). Stallman believed that software should be free\u2014not just free like \"free pizza,\" but free like \"freedom.\" Users should be able to:</p> <ul> <li>Run the program however they want</li> <li>Study how the program works</li> <li>Share copies with friends</li> <li>Modify the program and share improvements</li> </ul> <p>In 1983, Stallman announced the GNU Project (GNU stands for \"GNU's Not Unix\"\u2014programmers love recursive jokes). His goal was to create a complete, free operating system that was compatible with UNIX but didn't use any of AT&amp;T's code.</p> <p>Stallman and the GNU Project created amazing software:</p> <ul> <li>GCC \u2013 the GNU Compiler Collection (compiles code into programs)</li> <li>GNU Emacs \u2013 a powerful text editor (rival to <code>vi</code>!)</li> <li>Bash \u2013 the shell you'll be using throughout this course!</li> <li>GNU core utilities \u2013 <code>ls</code>, <code>cp</code>, <code>mv</code>, and dozens of other essential commands</li> </ul> <p>By 1990, GNU had almost everything needed for a complete operating system. Almost. They were missing one crucial piece: the kernel.</p>"},{"location":"chapters/01-unix-history/#diagram-open-source-vs-proprietary-software","title":"Diagram: Open Source vs Proprietary Software","text":"<pre><code>&lt;summary&gt;Open Source vs Proprietary Software&lt;/summary&gt;\nType: infographic\n\nBloom Taxonomy: Understand\nLearning Objective: Help students understand the difference between open source and proprietary software through visual comparison.\n\nLayout: Two-column comparison with icons and simple graphics\n\nLeft Column - Open Source (Green theme):\n- Icon: Open book or unlocked padlock\n- \"You CAN see the code\"\n- \"You CAN modify it\"\n- \"You CAN share it\"\n- Examples: Linux, Firefox, VLC, Blender\n- Vibe: Community collaboration illustration\n\nRight Column - Proprietary (Orange theme):\n- Icon: Closed book or locked padlock\n- \"Code is SECRET\"\n- \"Modification FORBIDDEN\"\n- \"Sharing may be ILLEGAL\"\n- Examples: Windows, Photoshop, Microsoft Office\n- Vibe: Corporate building illustration\n\nBottom section:\n- \"Both approaches have pros and cons!\"\n- Brief note: Open source = transparency, community; Proprietary = dedicated support, polished UX\n\nInteractive features:\n- Hover over examples to see more details\n- Toggle to reveal \"what happens if you try to modify proprietary software\" (spoiler: lawyers)\n\nImplementation: HTML/CSS or p5.js\n</code></pre>"},{"location":"chapters/01-unix-history/#linux-is-born-a-finnish-student-changes-the-world","title":"Linux Is Born: A Finnish Student Changes the World","text":"<p>And now we arrive at the star of our show: Linux.</p> <p>In 1991, a 21-year-old computer science student at the University of Helsinki named Linus Torvalds was bored. He had a new computer with an Intel 386 processor, and he wanted to learn how it worked. He started playing with MINIX (a teaching version of UNIX) but found it too limited.</p> <p>So, like any reasonable person, he decided to write his own operating system kernel. You know, as a hobby.</p> <p>On August 25, 1991, Linus posted this humble message to a newsgroup:</p> <p>\"I'm doing a (free) operating system (just a hobby, won't be big and professional like gnu) for 386(486) AT clones.\"</p> <p>Spoiler alert: It got big. REALLY big.</p> <p>The Linux kernel was the missing piece that the GNU Project needed. Combine Linux (the kernel) with GNU (all the tools and utilities), and you have a complete, free, open-source operating system. Technically, it should be called \"GNU/Linux,\" but most people just call it \"Linux.\" (This annoys Richard Stallman greatly, and honestly, he has a point.)</p> <p>What's a Kernel?</p> <p>The kernel is the core of an operating system\u2014the part that talks directly to the hardware. If the OS is a restaurant manager, the kernel is the manager's brain. Everything else (the shell, applications, utilities) builds on top of the kernel.</p>"},{"location":"chapters/01-unix-history/#why-did-linux-take-off","title":"Why Did Linux Take Off?","text":"<p>Linux succeeded where other free UNIX alternatives struggled for several reasons:</p> <ol> <li>Perfect timing \u2013 Released just when the internet was starting to grow</li> <li>Open development \u2013 Anyone could contribute code</li> <li>The GPL license \u2013 Ensured it would stay free forever</li> <li>Linus's leadership \u2013 He was (mostly) nice about accepting contributions</li> <li>Community \u2013 Passionate developers worldwide collaborated online</li> </ol> <p>Within a few years, Linux went from a student's hobby project to running stock exchanges, powering web servers, and eventually becoming the most widely-deployed operating system in history.</p> Where Linux Runs % of Market Web servers ~96% of top million websites Supercomputers 100% of top 500 Android phones 71% of mobile market Cloud computing ~90% of public cloud Smart TVs, routers, etc. The majority <p>Let that sink in: When you use Google, Facebook, Amazon, or basically any website, you're probably talking to a Linux server. Your Android phone runs Linux. Your smart TV probably runs Linux. The International Space Station runs Linux. Tesla cars run Linux. Linux is EVERYWHERE.</p>"},{"location":"chapters/01-unix-history/#diagram-linux-timeline","title":"Diagram: Linux Timeline","text":"<pre><code>&lt;summary&gt;Linux Timeline - From Hobby to World Domination&lt;/summary&gt;\nType: timeline\n\nBloom Taxonomy: Remember\nLearning Objective: Help students remember key milestones in Linux history and appreciate how quickly it evolved from a hobby project to global infrastructure.\n\nTime period: 1991-2025\n\nOrientation: Horizontal\n\nMilestones with icons:\n- 1991: \ud83d\udc23 Linus posts first announcement (August 25)\n- 1992: \ud83d\udcdc Linux adopts GPL license\n- 1993: \ud83d\udc27 Over 100 developers contributing; first \"distributions\" appear (Slackware, Debian)\n- 1994: \ud83c\udf89 Linux 1.0 released\n- 1996: \ud83d\udc27 Tux the penguin becomes mascot\n- 1998: \ud83c\udfe2 Major companies (IBM, Oracle) announce Linux support\n- 2000: \ud83d\udcb0 Red Hat becomes first $1B open source company\n- 2004: \ud83d\udfe0 Ubuntu launches - \"Linux for human beings\"\n- 2008: \ud83d\udcf1 Android (Linux-based) launches\n- 2012: \u2601\ufe0f Linux dominates cloud computing\n- 2015: \ud83c\udfe2 Microsoft says \"we love Linux\" (plot twist!)\n- 2020: \ud83d\ude80 All top 500 supercomputers run Linux\n- 2025: \ud83c\udf0d Linux is everywhere\n\nVisual style: Horizontal timeline with alternating above/below events\n\nColor coding:\n- Green: Community milestones\n- Blue: Technical releases\n- Orange: Commercial adoption\n- Purple: Mobile/modern era\n\nInteractive features:\n- Hover for more details\n- Click to see screenshots from that era\n\nImplementation: vis-timeline or HTML/CSS/SVG\n</code></pre>"},{"location":"chapters/01-unix-history/#linux-distributions-pick-your-flavor","title":"Linux Distributions: Pick Your Flavor!","text":"<p>Here's something that confuses newcomers: There's no single \"Linux.\" Instead, there are hundreds of Linux distributions (or \"distros\")\u2014different organizations packaging the Linux kernel with various software, configurations, and design choices.</p> <p>It's like ice cream: the base is the same (milk, sugar, cream), but you can have chocolate, vanilla, strawberry, rocky road, or that weird lavender flavor the fancy shop sells. Linux distributions are similar\u2014same kernel, different everything else.</p>"},{"location":"chapters/01-unix-history/#debian-the-grandparent-of-many","title":"Debian: The Grandparent of Many","text":"<p>Debian was founded in 1993 by Ian Murdock (the name combines \"Debra\" + \"Ian\"\u2014his girlfriend's name and his own. Aww! \ud83d\udc95). Debian is known for:</p> <ul> <li>Stability \u2013 Debian stable releases are ROCK solid</li> <li>Huge software repository \u2013 Over 59,000 packages!</li> <li>Community governance \u2013 No single company controls it</li> <li>apt \u2013 The package manager you'll learn to love</li> </ul> <p>Debian is like the sensible, reliable family sedan of Linux distributions. It's not flashy, but it works, and it spawned many \"children\" including the most popular desktop Linux...</p>"},{"location":"chapters/01-unix-history/#ubuntu-linux-for-human-beings","title":"Ubuntu: Linux for Human Beings","text":"<p>Ubuntu was released in 2004 by a company called Canonical, founded by South African entrepreneur Mark Shuttleworth. The name \"Ubuntu\" comes from a South African philosophy meaning \"humanity towards others\" or \"I am because we are.\"</p> <p>Ubuntu's mission was to make Linux easy enough for regular people to use. And it largely succeeded! Ubuntu features:</p> <ul> <li>User-friendly installation \u2013 Grandma could probably do it</li> <li>Regular releases \u2013 New version every 6 months</li> <li>Long-term support (LTS) \u2013 Enterprise-grade stability</li> <li>Great hardware support \u2013 Stuff usually \"just works\"</li> <li>Massive community \u2013 Help is always available</li> </ul> <p>If you're running Linux on a Raspberry Pi for this class, there's a good chance you're using Ubuntu or Raspberry Pi OS (which is based on Debian).</p> <p>The Distro Family Tree</p> <ul> <li>Debian \u2192 Ubuntu \u2192 Linux Mint, Pop!_OS, Elementary OS</li> <li>Debian \u2192 Raspberry Pi OS</li> <li>Red Hat \u2192 Fedora \u2192 CentOS, Rocky Linux</li> <li>Arch \u2192 Manjaro, EndeavourOS</li> <li>Slackware \u2192 (Various, more independent distros)</li> </ul> <p>When you see \"based on,\" it means they inherited code, tools, and packaging systems from their parent distro.</p>"},{"location":"chapters/01-unix-history/#diagram-linux-distribution-comparison","title":"Diagram: Linux Distribution Comparison","text":"<pre><code>&lt;summary&gt;Linux Distribution Comparison Chart&lt;/summary&gt;\nType: chart\n\nBloom Taxonomy: Analyze, Evaluate\nLearning Objective: Help students understand the differences between major Linux distributions and when each might be appropriate.\n\nChart type: Comparison matrix/table with visual elements\n\nCategories (rows):\n- Debian\n- Ubuntu\n- Fedora\n- Arch Linux\n- Linux Mint\n\nAttributes (columns):\n- User Friendliness (1-5 stars)\n- Stability (1-5 stars)\n- Software Freshness (1-5 stars)\n- Learning Curve (Easy/Medium/Hard)\n- Best For (description)\n\nData:\n| Distro | User Friendly | Stability | Fresh Software | Learning Curve | Best For |\n|--------|--------------|-----------|----------------|----------------|----------|\n| Debian | \u2b50\u2b50\u2b50 | \u2b50\u2b50\u2b50\u2b50\u2b50 | \u2b50\u2b50 | Medium | Servers, stability |\n| Ubuntu | \u2b50\u2b50\u2b50\u2b50\u2b50 | \u2b50\u2b50\u2b50\u2b50 | \u2b50\u2b50\u2b50\u2b50 | Easy | Beginners, desktop |\n| Fedora | \u2b50\u2b50\u2b50\u2b50 | \u2b50\u2b50\u2b50\u2b50 | \u2b50\u2b50\u2b50\u2b50\u2b50 | Medium | Developers |\n| Arch | \u2b50\u2b50 | \u2b50\u2b50\u2b50\u2b50 | \u2b50\u2b50\u2b50\u2b50\u2b50 | Hard | Learning, customization |\n| Mint | \u2b50\u2b50\u2b50\u2b50\u2b50 | \u2b50\u2b50\u2b50\u2b50 | \u2b50\u2b50\u2b50 | Easy | Windows converts |\n\nVisual elements:\n- Each distro's logo next to its name\n- Color-coded ratings (green=good, yellow=medium, red=challenging)\n\nImplementation: HTML/CSS table or Chart.js\n</code></pre>"},{"location":"chapters/01-unix-history/#posix-making-everyone-play-nice","title":"POSIX: Making Everyone Play Nice","text":"<p>With all these different UNIX versions and Linux distributions running around, you might wonder: How does software know how to work on all of them? Enter POSIX (Portable Operating System Interface).</p> <p>POSIX is a set of standards created by the IEEE (Institute of Electrical and Electronics Engineers) that defines how a UNIX-like operating system should behave. It's like a rulebook that says:</p> <ul> <li>\"The <code>ls</code> command should work THIS way\"</li> <li>\"Files should be organized THAT way\"</li> <li>\"Programs should talk to the OS LIKE SO\"</li> </ul> <p>When an operating system is \"POSIX-compliant,\" it means software written for one POSIX system should work on another. This is why you can learn Linux commands and then use them on macOS (mostly), FreeBSD, and other UNIX-like systems.</p> <p>POSIX compliance is like everyone agreeing to drive on the same side of the road. Without it, crossing borders (or moving your code between systems) would be chaos!</p>"},{"location":"chapters/01-unix-history/#why-does-all-this-history-matter-to-you","title":"Why Does All This History Matter to YOU?","text":"<p>Okay, so we've covered a lot of history. Dead people (RIP Dennis Ritchie, 2011), old computers, corporate lawsuits, Finnish students... why should YOU care?</p> <p>Here's why:</p> <ol> <li> <p>Linux powers the modern world \u2013 If you want a career in tech, you WILL encounter Linux. Web development? Linux servers. Data science? Linux. Cybersecurity? Linux. Game development? Often Linux. Cloud computing? Definitely Linux.</p> </li> <li> <p>The UNIX philosophy still guides software design \u2013 The idea of small, modular tools that work together is everywhere. Microservices, APIs, the command line\u2014all follow UNIX principles.</p> </li> <li> <p>Understanding history helps you understand the present \u2013 Why does macOS have a command line? (BSD!) Why do some things work the same on Mac and Linux? (POSIX!) Why is the C language still important? (Everything is built on it!)</p> </li> <li> <p>Open source is the future \u2013 The collaborative model that Linux pioneered is now how much of the tech world works. Understanding this culture helps you participate in it.</p> </li> <li> <p>It's actually a cool story! \u2013 A video game, a student's hobby project, a bearded guy who really cares about freedom... tech history is wild, and knowing it makes you a more interesting person at parties. (Okay, specific kinds of parties.)</p> </li> </ol>"},{"location":"chapters/01-unix-history/#diagram-microsim-unix-commands-explorer","title":"Diagram: MicroSim - UNIX Commands Explorer","text":"<pre><code>&lt;summary&gt;UNIX Commands Explorer MicroSim&lt;/summary&gt;\nType: microsim\n\nBloom Taxonomy: Remember, Apply\nLearning Objective: Help students interactively explore common UNIX/Linux commands and their origins, reinforcing the connection between history and practical skills.\n\nCanvas layout (responsive, ~700px max width):\n- Top area (400px height): Visualization area\n- Bottom area (150px height): Control panel\n\nVisual elements:\n- Interactive terminal-like display showing command preview\n- Timeline ribbon showing when command was introduced\n- Category icons (file management, text processing, system, network)\n- \"Fun fact\" bubble that appears with historical context\n\nInteractive controls:\n- Dropdown: Select category (Files, Text, System, Network)\n- List/buttons: Select specific command\n- \"Try it!\" button that shows example usage\n- \"History\" button that shows when/where command originated\n\nCommand data (subset):\n- ls (1971, original UNIX) - \"List files - Ken Thompson's creation\"\n- cat (1971, original UNIX) - \"ConCATenate files together\"\n- grep (1973, Ken Thompson) - \"Name comes from ed command g/re/p\"\n- chmod (1971) - \"CHange MODe of file permissions\"\n- sudo (1980, BSD) - \"Super User DO - get root powers!\"\n\nBehavior:\n- When command selected, show:\n  - Basic syntax example\n  - When it was created\n  - Fun historical fact\n  - Common use case\n- Animation: Command typing effect in terminal preview\n- Sound option: Terminal beep (muted by default)\n\nDefault state:\n- Category: Files\n- Selected: ls\n- Shows welcoming message about exploring UNIX history\n\nImplementation: p5.js\n\nNote: This MicroSim bridges history content with practical command learning that will come in later chapters.\n</code></pre>"},{"location":"chapters/01-unix-history/#key-takeaways","title":"Key Takeaways","text":"<p>Before we move on to actually USING Linux (the fun part!), let's recap what we've learned:</p> <ul> <li>An operating system manages your computer's resources and lets programs run</li> <li>UNIX was created at Bell Labs in 1969 by Ken Thompson and Dennis Ritchie</li> <li>Dennis Ritchie created the C programming language, making software portable</li> <li>The UNIX Philosophy emphasizes small, modular tools that work together</li> <li>BSD Unix came from UC Berkeley and powers things like Netflix and macOS</li> <li>UNIX System V was the commercial AT&amp;T version</li> <li>Richard Stallman started the GNU Project to create free software</li> <li>Linus Torvalds created the Linux kernel in 1991 as a hobby project</li> <li>Linux distributions like Debian and Ubuntu package Linux for different uses</li> <li>POSIX standards ensure compatibility between UNIX-like systems</li> <li>Open source collaboration made Linux the most widely-deployed OS in history</li> </ul> <p>You Made It!</p> <p>Congratulations\u2014you now know more about UNIX and Linux history than 99% of people! You understand why the command line exists, where Linux came from, and why it matters. In the next chapters, we'll stop talking about history and start DOING things with Linux. Get ready to type!</p>"},{"location":"chapters/01-unix-history/#whats-next","title":"What's Next?","text":"<p>Now that you understand where Linux came from, it's time to actually USE it! In the upcoming chapters, you'll:</p> <ul> <li>Learn to navigate the file system like a pro</li> <li>Master essential commands that haven't changed since the 1970s (they're that good!)</li> <li>Customize your terminal to look awesome</li> <li>Write your first shell scripts</li> <li>Connect to remote servers</li> <li>And much more!</li> </ul> <p>The journey to becoming a Linux master starts with understanding its roots. You've taken that first step. Now let's keep moving forward!</p> Quick Quiz: Test Your Knowledge! <ol> <li>Where was UNIX created?</li> <li>Who created the C programming language?</li> <li>What does GNU stand for?</li> <li>In what year did Linus Torvalds release Linux?</li> <li>Name one Linux distribution based on Debian.</li> </ol> Quiz Answers <ol> <li>Bell Labs (Murray Hill, New Jersey)</li> <li>Dennis Ritchie</li> <li>GNU's Not Unix</li> <li>1991</li> <li>Ubuntu, Raspberry Pi OS, Linux Mint (any of these!)</li> </ol>"},{"location":"chapters/02-terminal-basics/","title":"Getting Started with the Terminal","text":""},{"location":"chapters/02-terminal-basics/#summary","title":"Summary","text":"<p>This chapter introduces you to the command line interface, the powerful text-based way to interact with Linux. You'll learn about different shells (Bash and Zsh), how to use the terminal emulator, and master essential navigation techniques like tab completion and command history. These foundational skills will serve you throughout your Linux journey and make you dramatically more productive.</p>"},{"location":"chapters/02-terminal-basics/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 20 concepts from the learning graph:</p> <ol> <li>Shell</li> <li>Bash Shell</li> <li>Zsh Shell</li> <li>Terminal Emulator</li> <li>Command Line Interface</li> <li>Shell Prompt</li> <li>Command Syntax</li> <li>Command Arguments</li> <li>Command Options</li> <li>Command Flags</li> <li>Tab Completion</li> <li>Command History</li> <li>History Command</li> <li>Arrow Key Navigation</li> <li>Ctrl Key Shortcuts</li> <li>Clear Command</li> <li>Exit Command</li> <li>Login Shell</li> <li>Interactive Shell</li> <li>Non-Interactive Shell</li> </ol>"},{"location":"chapters/02-terminal-basics/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 1: Introduction to Operating Systems and UNIX History</li> </ul>"},{"location":"chapters/02-terminal-basics/#welcome-to-the-matrix-sort-of","title":"Welcome to the Matrix (Sort Of)","text":"<p>Okay, you've learned the history. You know about Thompson, Ritchie, Torvalds, and all those computing legends. Now it's time to stop reading about Linux and start DOING Linux. And that means one thing: the command line.</p> <p>If you've ever seen a movie where a hacker furiously types green text on a black screen while dramatic music plays... that's the command line. (Well, a Hollywood version of it. Real hacking involves a lot more Googling and coffee.)</p> <p>The command line might look intimidating at first\u2014just a blinking cursor waiting for you to type something. But here's the secret: the command line is actually your friend. It's faster than clicking through menus, more powerful than any graphical interface, and once you learn it, you'll wonder how you ever lived without it.</p> <p>Why Bother with the Command Line?</p> <ul> <li>Speed \u2013 Type a command in 2 seconds vs. clicking through 5 menus</li> <li>Power \u2013 Do things that are impossible in graphical interfaces</li> <li>Automation \u2013 Write scripts to do repetitive tasks for you</li> <li>Remote access \u2013 Control servers on the other side of the world</li> <li>Cool factor \u2013 Let's be honest, it looks awesome</li> </ul> <p>Let's dive in!</p>"},{"location":"chapters/02-terminal-basics/#what-is-a-shell","title":"What is a Shell?","text":"<p>When you type commands in the terminal, you're not actually talking directly to the Linux kernel (the core of the operating system). Instead, you're talking to a program called a shell.</p> <p>Think of the shell as a translator between you and the operating system. You speak Human (well, Human-ish commands), the shell translates that into something the kernel understands, the kernel does the work, and then the shell shows you the results.</p> <p>The word \"shell\" makes sense when you think about it\u2014it's the outer layer that wraps around the kernel, just like an egg shell wraps around the egg inside. (I promise that's the last egg-related metaphor. Maybe.)</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502            YOU                  \u2502\n\u2502     (typing commands)           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                \u2502\n                \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502           SHELL                 \u2502\n\u2502  (interprets your commands)     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                \u2502\n                \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502          KERNEL                 \u2502\n\u2502   (does the actual work)        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>The shell does several important jobs:</p> <ul> <li>Interprets commands \u2013 Figures out what you're asking for</li> <li>Manages processes \u2013 Starts and stops programs</li> <li>Handles input/output \u2013 Connects programs together (remember pipes from Chapter 1?)</li> <li>Provides scripting \u2013 Lets you automate tasks with shell scripts</li> <li>Maintains your environment \u2013 Keeps track of settings and variables</li> </ul>"},{"location":"chapters/02-terminal-basics/#a-brief-history-of-shells","title":"A Brief History of Shells","text":"<p>Just like there are different web browsers (Chrome, Firefox, Safari), there are different shells. They all do basically the same thing, but with different features and syntax quirks.</p> Shell Name Stands For Year Fun Fact sh Bourne Shell 1979 The original! Written by Stephen Bourne csh C Shell 1978 Syntax looks like C programming ksh Korn Shell 1983 Combined best of sh and csh bash Bourne Again Shell 1989 Get it? \"Born again\"? Programmers love puns zsh Z Shell 1990 The \"ultimate\" shell (z = last letter) fish Friendly Interactive Shell 2005 Focus on user-friendliness <p>For this course, we'll focus on the two most popular shells on modern Linux systems: Bash and Zsh.</p>"},{"location":"chapters/02-terminal-basics/#bash-the-default-champion","title":"Bash: The Default Champion","text":"<p>The Bash Shell (Bourne Again Shell) is the most widely used shell in the Linux world. It's been the default shell on most Linux distributions for decades, and it's what you'll find on:</p> <ul> <li>Most Linux servers</li> <li>Raspberry Pi (Raspberry Pi OS)</li> <li>macOS (until recently)</li> <li>Windows Subsystem for Linux (WSL)</li> <li>Git Bash on Windows</li> </ul> <p>Bash was created in 1989 by Brian Fox as a free software replacement for the original Bourne shell. Remember the GNU Project from Chapter 1? Bash was one of their key achievements!</p> <p>Bash is like the Honda Civic of shells\u2014reliable, everywhere, well-documented, and gets the job done. Not flashy, but you can't go wrong with it.</p> <pre><code># Check if you're running Bash\necho $SHELL\n# Output: /bin/bash\n\n# Or check the version\nbash --version\n# Output: GNU bash, version 5.x.x...\n</code></pre>"},{"location":"chapters/02-terminal-basics/#zsh-the-fancy-newcomer","title":"Zsh: The Fancy Newcomer","text":"<p>The Zsh Shell (Z Shell) is like Bash's cooler younger sibling who went to art school. It does everything Bash does, but with more style and extra features.</p> <p>Zsh has been around since 1990, but it really took off when Apple made it the default shell on macOS starting with Catalina (2019). Suddenly millions of developers were using Zsh, and the ecosystem exploded with themes and plugins.</p> <p>What makes Zsh special?</p> <ul> <li>Better tab completion \u2013 It's almost psychic</li> <li>Spelling correction \u2013 \"Did you mean 'git'?\"</li> <li>Themes and customization \u2013 Make your terminal beautiful</li> <li>Plugin ecosystem \u2013 Especially with Oh My Zsh</li> <li>Shared command history \u2013 Between terminal windows</li> </ul> <pre><code># Check if you're running Zsh\necho $SHELL\n# Output: /bin/zsh\n\n# Zsh version\nzsh --version\n# Output: zsh 5.x.x...\n</code></pre> <p>Bash vs Zsh: Which Should You Use?</p> <p>For learning, Bash is the better choice because:</p> <ul> <li>More tutorials and documentation exist for Bash</li> <li>Most servers run Bash</li> <li>Scripts written in Bash work almost everywhere</li> <li>Once you know Bash, switching to Zsh is easy</li> </ul> <p>That said, if you're on a Mac or just want a fancier experience, Zsh is great too! Most commands work identically in both.</p>"},{"location":"chapters/02-terminal-basics/#diagram-shell-comparison","title":"Diagram: Shell Comparison","text":"<pre><code>&lt;summary&gt;Bash vs Zsh Feature Comparison&lt;/summary&gt;\nType: infographic\n\nBloom Taxonomy: Understand, Analyze\nLearning Objective: Help students understand the key differences between Bash and Zsh to make informed choices about which shell to use.\n\nLayout: Two-column comparison with visual icons and ratings\n\nLeft Column - Bash (Orange theme):\n- Logo/Icon: Terminal with $ prompt\n- \"The Classic\"\n- Strengths:\n  - Universal compatibility (5 stars)\n  - Documentation available (5 stars)\n  - Server standard (5 stars)\n  - Beginner resources (5 stars)\n- Weaknesses:\n  - Customization (3 stars)\n  - Tab completion (3 stars)\n  - Modern features (3 stars)\n\nRight Column - Zsh (Green theme):\n- Logo/Icon: Terminal with % prompt\n- \"The Modern Choice\"\n- Strengths:\n  - Tab completion (5 stars)\n  - Customization (5 stars)\n  - Plugin ecosystem (5 stars)\n  - User experience (5 stars)\n- Weaknesses:\n  - Learning curve (4 stars)\n  - Script portability (4 stars)\n\nBottom section:\n- Venn diagram showing: Both support same basic commands\n- \"Start with Bash, graduate to Zsh when ready!\"\n\nInteractive features:\n- Hover for detailed explanations\n- Click examples to see syntax differences\n\nImplementation: HTML/CSS or p5.js\n</code></pre>"},{"location":"chapters/02-terminal-basics/#the-terminal-emulator-your-window-to-the-shell","title":"The Terminal Emulator: Your Window to the Shell","text":"<p>Here's something that confuses beginners: the terminal emulator and the shell are NOT the same thing.</p> <p>The shell is the program that interprets your commands (Bash, Zsh, etc.).</p> <p>The terminal emulator is the window/application that displays the shell and lets you type into it.</p> <p>Think of it like watching TV: the shell is the TV show (the content), and the terminal emulator is the TV set (how you view it). You can watch the same show on different TVs, and you can run the same shell in different terminal emulators.</p> <p>Popular terminal emulators include:</p> Terminal Platform Notable Feature GNOME Terminal Linux Default on Ubuntu and many distros Konsole Linux KDE's terminal, very customizable iTerm2 macOS Split panes, search, profiles Terminal.app macOS Built-in, simple Windows Terminal Windows Modern, tabbed, customizable Alacritty Cross-platform GPU-accelerated, blazing fast Kitty Cross-platform GPU-based, images in terminal! <p>For this course, whatever terminal emulator came with your system is perfectly fine. They all do the same basic job of giving you access to the shell.</p> <p>Opening the Terminal</p> <ul> <li>Ubuntu/Linux: Press <code>Ctrl+Alt+T</code> or search for \"Terminal\"</li> <li>macOS: Press <code>Cmd+Space</code>, type \"Terminal\", hit Enter</li> <li>Raspberry Pi: Click the terminal icon in the taskbar</li> <li>Windows (WSL): Search for \"Ubuntu\" or \"Windows Terminal\"</li> </ul>"},{"location":"chapters/02-terminal-basics/#the-command-line-interface","title":"The Command Line Interface","text":"<p>When you open a terminal, you're greeted by the command line interface (CLI). Unlike a graphical user interface (GUI) where you click buttons and icons, a CLI is all text\u2014you type commands, and it types back results.</p> <p>The CLI consists of:</p> <ol> <li>The prompt \u2013 Shows you're ready for input</li> <li>Your command \u2013 What you type</li> <li>The output \u2013 What the computer responds with</li> </ol> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 dan@raspberry:~$                               \u2502  \u2190 The prompt\n\u2502 dan@raspberry:~$ ls                            \u2502  \u2190 You type \"ls\"\n\u2502 Documents  Downloads  Pictures  Videos         \u2502  \u2190 The output\n\u2502 dan@raspberry:~$                               \u2502  \u2190 Ready for next command\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>The CLI might seem old-fashioned compared to pretty graphical interfaces, but it has MASSIVE advantages:</p> <ul> <li>Precision \u2013 Say exactly what you want</li> <li>Speed \u2013 Faster than clicking through menus</li> <li>Scriptability \u2013 Automate repeated tasks</li> <li>Remote access \u2013 Works over slow connections</li> <li>Resource-efficient \u2013 Uses almost no memory or CPU</li> </ul>"},{"location":"chapters/02-terminal-basics/#anatomy-of-the-shell-prompt","title":"Anatomy of the Shell Prompt","text":"<p>The shell prompt is that little bit of text that appears when the terminal is waiting for you to type something. It might look something like:</p> <pre><code>dan@raspberry:~$\n</code></pre> <p>Let's decode this:</p> Part Meaning <code>dan</code> Your username <code>@</code> \"at\" separator <code>raspberry</code> The hostname (computer's name) <code>:</code> Separator <code>~</code> Current directory (~ means home folder) <code>$</code> You're a regular user (# means root/admin) <p>The prompt can be customized to show all sorts of information\u2014time, git branch, battery level, weather (okay, maybe not weather). We'll cover customization in a later chapter.</p> <p>The Superuser Prompt</p> <p>If your prompt ends with <code>#</code> instead of <code>$</code>, you're logged in as the root user (superuser/administrator). Be careful! Root can delete anything, including critical system files. Only use root when necessary.</p> <pre><code>root@raspberry:~#  \u2190 This is root! Be careful!\n</code></pre>"},{"location":"chapters/02-terminal-basics/#diagram-anatomy-of-a-shell-prompt","title":"Diagram: Anatomy of a Shell Prompt","text":"<pre><code>&lt;summary&gt;Understanding the Shell Prompt&lt;/summary&gt;\nType: diagram\n\nBloom Taxonomy: Remember, Understand\nLearning Objective: Help students recognize and understand each component of a typical shell prompt.\n\nComponents to show:\n- A sample prompt: \"dan@raspberry:~/Documents$\"\n- Callout boxes pointing to each part with explanations\n- Color coding for each component\n\nLayout: Horizontal prompt with annotation arrows pointing to each section\n\nLabels and arrows:\n- \"dan\" \u2192 \"Username (who you are)\"\n- \"@\" \u2192 \"At separator\"\n- \"raspberry\" \u2192 \"Hostname (which computer)\"\n- \":\" \u2192 \"Separator\"\n- \"~/Documents\" \u2192 \"Current directory (where you are)\"\n- \"$\" \u2192 \"User indicator ($ = normal, # = root)\"\n\nAdditional examples below:\n- \"student@ubuntu:~$\" - Ubuntu default\n- \"pi@raspberrypi:~$\" - Raspberry Pi default\n- \"root@server:/#\" - Root user (danger zone!)\n\nColor scheme:\n- Username: Blue\n- Hostname: Green\n- Path: Yellow/Orange\n- Prompt symbol: Red (if root) or Gray (if normal)\n\nInteractive features:\n- Hover over each part for detailed explanation\n- Click to see different prompt styles\n\nImplementation: HTML/CSS or p5.js\n</code></pre>"},{"location":"chapters/02-terminal-basics/#command-syntax-the-grammar-of-linux","title":"Command Syntax: The Grammar of Linux","text":"<p>Every command you type follows a specific pattern. Understanding command syntax is like learning the grammar of a new language\u2014once you get it, everything makes sense.</p> <p>The basic structure is:</p> <pre><code>command [options] [arguments]\n</code></pre> <p>Let's break this down:</p> <ul> <li>command \u2013 The program you want to run (like <code>ls</code>, <code>cd</code>, <code>cp</code>)</li> <li>options \u2013 Modifiers that change how the command works (usually start with <code>-</code> or <code>--</code>)</li> <li>arguments \u2013 The things you want the command to work on (files, directories, etc.)</li> </ul> <p>Here's a real example:</p> <pre><code>ls -la /home/dan\n</code></pre> Part What It Is What It Does <code>ls</code> Command Lists directory contents <code>-la</code> Options <code>-l</code> = long format, <code>-a</code> = show hidden files <code>/home/dan</code> Argument The directory to list <p>Spaces Matter!</p> <p>In the command line, spaces separate different parts of the command. This means:</p> <ul> <li><code>ls -la</code> = the <code>ls</code> command with options <code>-la</code></li> <li><code>ls-la</code> = trying to run a command literally called \"ls-la\" (doesn't exist!)</li> </ul> <p>If you need to use a filename with spaces, put it in quotes: <code>\"my file.txt\"</code></p>"},{"location":"chapters/02-terminal-basics/#options-and-flags-customizing-commands","title":"Options and Flags: Customizing Commands","text":"<p>Command options (also called command flags) modify how a command behaves. They're like the settings on a video game\u2014same game, different experience.</p> <p>Most options come in two flavors:</p>"},{"location":"chapters/02-terminal-basics/#short-options-single-dash","title":"Short Options (Single Dash)","text":"<p>Short options use a single dash followed by a letter:</p> <pre><code>ls -l    # Long listing format\nls -a    # Show all files (including hidden)\nls -h    # Human-readable file sizes\n</code></pre> <p>You can combine short options:</p> <pre><code>ls -l -a -h    # Three separate options\nls -lah        # Same thing, combined (order doesn't matter)\n</code></pre>"},{"location":"chapters/02-terminal-basics/#long-options-double-dash","title":"Long Options (Double Dash)","text":"<p>Long options use two dashes followed by a word:</p> <pre><code>ls --all           # Same as -a\nls --human-readable # Same as -h\nls --help          # Show help for the command\n</code></pre> <p>Long options are easier to remember and read, but take longer to type. Use whichever you prefer!</p> <pre><code># These all do the same thing:\nls -a\nls --all\n# Most people use -a because it's faster to type\n</code></pre>"},{"location":"chapters/02-terminal-basics/#diagram-command-syntax-breakdown","title":"Diagram: Command Syntax Breakdown","text":"<pre><code>&lt;summary&gt;Command Syntax Visual Guide&lt;/summary&gt;\nType: diagram\n\nBloom Taxonomy: Understand, Apply\nLearning Objective: Visualize the structure of Linux commands and understand how options and arguments work together.\n\nComponents:\n- Large example command: \"cp -rv ~/Documents/project /backup/\"\n- Color-coded boxes around each part\n- Annotation lines with explanations\n\nMain visualization:\n- Command box (Blue): \"cp\" - \"The program to run\"\n- Options box (Green): \"-rv\" - \"How to run it\"\n  - Expanded: \"-r = recursive, -v = verbose\"\n- Argument 1 box (Orange): \"~/Documents/project\" - \"Source (from)\"\n- Argument 2 box (Purple): \"/backup/\" - \"Destination (to)\"\n\nBelow: Three more examples showing the pattern\n1. \"ls\" - command only (no options or arguments)\n2. \"ls -la\" - command with options\n3. \"cat file.txt\" - command with argument\n4. \"grep -i 'hello' file.txt\" - command with options and multiple arguments\n\nInteractive elements:\n- Hover over each colored section for tooltips\n- Toggle between different example commands\n\nImplementation: HTML/CSS or p5.js\n</code></pre>"},{"location":"chapters/02-terminal-basics/#command-arguments-telling-commands-what-to-work-on","title":"Command Arguments: Telling Commands What to Work On","text":"<p>Command arguments are the targets of your command\u2014the files, directories, or other inputs you want the command to process.</p> <p>Some commands require arguments:</p> <pre><code>cd /home        # cd needs a directory to change to\ncat file.txt    # cat needs a file to display\ncp a.txt b.txt  # cp needs source and destination\n</code></pre> <p>Some commands work without arguments (using defaults):</p> <pre><code>ls              # Lists current directory if no argument given\npwd             # Prints working directory (no argument needed)\ndate            # Shows current date/time (no argument needed)\n</code></pre> <p>Some commands accept multiple arguments:</p> <pre><code>cp file1.txt file2.txt file3.txt destination/  # Copy multiple files\ncat file1.txt file2.txt file3.txt              # Display multiple files\nrm file1.txt file2.txt file3.txt               # Delete multiple files\n</code></pre> <p>Reading Command Help</p> <p>When you see command documentation, brackets indicate optional parts:</p> <pre><code>ls [OPTION]... [FILE]...\n</code></pre> <p>This means: - <code>ls</code> \u2013 Can be run alone - <code>[OPTION]...</code> \u2013 Can have zero or more options - <code>[FILE]...</code> \u2013 Can have zero or more files</p> <p>The <code>...</code> means \"you can have multiple of these.\"</p>"},{"location":"chapters/02-terminal-basics/#tab-completion-your-new-best-friend","title":"Tab Completion: Your New Best Friend","text":"<p>Okay, here's where things get GOOD. Tab completion is one of the most useful features in the terminal, and once you start using it, you'll wonder how you ever typed full commands.</p> <p>The concept is simple: start typing something, press <code>Tab</code>, and the shell will try to complete it for you.</p>"},{"location":"chapters/02-terminal-basics/#completing-commands","title":"Completing Commands","text":"<pre><code># Type:\nhist&lt;Tab&gt;\n# Shell completes to:\nhistory\n</code></pre>"},{"location":"chapters/02-terminal-basics/#completing-file-names","title":"Completing File Names","text":"<pre><code># Your directory has: report_2024_final.pdf\n# Type:\ncat rep&lt;Tab&gt;\n# Shell completes to:\ncat report_2024_final.pdf\n</code></pre>"},{"location":"chapters/02-terminal-basics/#when-there-are-multiple-matches","title":"When There Are Multiple Matches","text":"<p>If there's more than one possibility, press <code>Tab</code> twice to see all options:</p> <pre><code># Directory has: file1.txt, file2.txt, file3.txt\n# Type:\ncat file&lt;Tab&gt;&lt;Tab&gt;\n# Shell shows:\nfile1.txt  file2.txt  file3.txt\n# Type more to narrow it down:\ncat file1&lt;Tab&gt;\n# Shell completes to:\ncat file1.txt\n</code></pre>"},{"location":"chapters/02-terminal-basics/#tab-completion-for-paths","title":"Tab Completion for Paths","text":"<p>You can tab-complete through directory paths:</p> <pre><code># Type:\ncd /ho&lt;Tab&gt;/da&lt;Tab&gt;/Doc&lt;Tab&gt;\n# Expands to:\ncd /home/dan/Documents/\n</code></pre> <p>Pro Tip: Tab Early, Tab Often</p> <p>Get in the habit of pressing Tab after typing just a few characters. This:</p> <ul> <li>Saves typing time</li> <li>Prevents typos</li> <li>Confirms the file/command exists</li> <li>Shows you what's available</li> </ul> <p>If Tab doesn't complete anything, it means nothing matches what you've typed!</p>"},{"location":"chapters/02-terminal-basics/#diagram-tab-completion-microsim","title":"Diagram: Tab Completion MicroSim","text":"<pre><code>&lt;summary&gt;Interactive Tab Completion Demo&lt;/summary&gt;\nType: microsim\n\nBloom Taxonomy: Apply\nLearning Objective: Let students practice tab completion in a safe, interactive environment before trying it on a real terminal.\n\nCanvas layout (responsive, ~700px max width):\n- Top area (350px): Simulated terminal display\n- Bottom area (150px): Instructions and hint panel\n\nVisual elements:\n- Terminal-style interface with black background, green text\n- Blinking cursor\n- File listing panel showing available files\n- \"Tab key\" visual indicator that lights up when pressed\n- Completion animation showing text being filled in\n\nSimulated file system:\n- Documents/\n  - report.txt\n  - readme.md\n  - research_notes.txt\n- Downloads/\n  - image.png\n  - installer.deb\n- Pictures/\n\nInteractive exercises (3 levels):\n1. Basic: Type \"cd Doc&lt;Tab&gt;\" - completes to \"cd Documents/\"\n2. Intermediate: Type \"cat re&lt;Tab&gt;&lt;Tab&gt;\" - shows options, complete \"cat readme.md\"\n3. Advanced: Type \"ls ~/Do&lt;Tab&gt;\" - multiple matches, narrow down\n\nControls:\n- Text input field for typing commands\n- Keyboard capture for Tab key\n- \"Reset\" button\n- \"Next Challenge\" button\n- Hint toggle\n\nBehavior:\n- Simulate actual tab completion behavior\n- Show visual feedback when Tab is pressed\n- Celebrate correct completions with brief animation\n- Provide helpful hints if stuck\n\nDefault state:\n- Level 1 challenge active\n- Instructions visible\n- Cursor blinking in terminal\n\nImplementation: p5.js\n</code></pre>"},{"location":"chapters/02-terminal-basics/#command-history-the-shell-remembers","title":"Command History: The Shell Remembers","text":"<p>Here's another massive productivity booster: the shell remembers every command you've typed. This is called command history, and it's saved even after you close the terminal.</p>"},{"location":"chapters/02-terminal-basics/#using-arrow-keys","title":"Using Arrow Keys","text":"<p>The simplest way to access history is with arrow key navigation:</p> <ul> <li>Up Arrow (\u2191) \u2013 Go to previous command</li> <li>Down Arrow (\u2193) \u2013 Go to next command</li> </ul> <p>Try it now! Open a terminal, type a few commands, then press Up Arrow to cycle through them.</p> <pre><code># Type these commands:\nls\npwd\ndate\n\n# Now press Up Arrow three times to go back through them\n</code></pre>"},{"location":"chapters/02-terminal-basics/#the-history-command","title":"The History Command","text":"<p>The history command shows your complete command history:</p> <pre><code>history\n# Output:\n  501  ls -la\n  502  cd Documents\n  503  cat readme.txt\n  504  pwd\n  505  history\n</code></pre> <p>Each command has a number. You can re-run any command using <code>!</code> followed by its number:</p> <pre><code>!501        # Runs: ls -la\n</code></pre>"},{"location":"chapters/02-terminal-basics/#history-shortcuts","title":"History Shortcuts","text":"<p>Here are some handy shortcuts:</p> Shortcut What It Does <code>!!</code> Run the last command again <code>!xyz</code> Run the most recent command starting with \"xyz\" <code>!?xyz</code> Run the most recent command containing \"xyz\" <code>!-2</code> Run the second-to-last command <code>history 10</code> Show only the last 10 commands <p>The <code>!!</code> shortcut is especially useful when you forget <code>sudo</code>:</p> <pre><code>apt update                    # Oops, need sudo!\n# Permission denied\nsudo !!                       # Runs: sudo apt update\n</code></pre>"},{"location":"chapters/02-terminal-basics/#searching-history-with-ctrlr","title":"Searching History with Ctrl+R","text":"<p>This one's a game-changer: Ctrl+R lets you search your command history interactively.</p> <ol> <li>Press <code>Ctrl+R</code></li> <li>Start typing any part of the command you're looking for</li> <li>It finds the most recent match</li> <li>Press <code>Ctrl+R</code> again to find older matches</li> <li>Press <code>Enter</code> to run the command, or <code>Esc</code> to edit it first</li> </ol> <pre><code># Press Ctrl+R, then type \"git\"\n(reverse-i-search)`git': git push origin main\n# Found it! Press Enter to run, or keep typing to narrow search\n</code></pre> <p>Where is History Stored?</p> <p>Your command history is saved in a hidden file in your home directory:</p> <ul> <li>Bash: <code>~/.bash_history</code></li> <li>Zsh: <code>~/.zsh_history</code></li> </ul> <p>You can view it with <code>cat ~/.bash_history</code> (or the appropriate file for your shell).</p>"},{"location":"chapters/02-terminal-basics/#essential-ctrl-key-shortcuts","title":"Essential Ctrl Key Shortcuts","text":"<p>Beyond Ctrl+R for history search, there are many Ctrl key shortcuts that make terminal work faster. These work in most shells and are worth memorizing.</p>"},{"location":"chapters/02-terminal-basics/#movement-shortcuts","title":"Movement Shortcuts","text":"Shortcut Action <code>Ctrl+A</code> Move cursor to beginning of line <code>Ctrl+E</code> Move cursor to end of line <code>Ctrl+B</code> Move cursor back one character <code>Ctrl+F</code> Move cursor forward one character <code>Alt+B</code> Move cursor back one word <code>Alt+F</code> Move cursor forward one word"},{"location":"chapters/02-terminal-basics/#editing-shortcuts","title":"Editing Shortcuts","text":"Shortcut Action <code>Ctrl+U</code> Delete from cursor to beginning of line <code>Ctrl+K</code> Delete from cursor to end of line <code>Ctrl+W</code> Delete the word before the cursor <code>Ctrl+Y</code> Paste (yank) previously deleted text <code>Ctrl+_</code> Undo last edit"},{"location":"chapters/02-terminal-basics/#control-shortcuts","title":"Control Shortcuts","text":"Shortcut Action <code>Ctrl+C</code> Cancel/kill the current command <code>Ctrl+D</code> Exit the shell (or send EOF) <code>Ctrl+Z</code> Suspend the current process <code>Ctrl+L</code> Clear the screen (same as <code>clear</code> command) <code>Ctrl+S</code> Pause terminal output (oh no!) <code>Ctrl+Q</code> Resume terminal output (phew!) <p>Ctrl+S Panic</p> <p>If your terminal suddenly freezes and won't respond to anything... you probably pressed <code>Ctrl+S</code> by accident. This is \"flow control\" that pauses output. Just press <code>Ctrl+Q</code> to unfreeze it!</p>"},{"location":"chapters/02-terminal-basics/#the-clear-command","title":"The Clear Command","text":"<p>Your terminal can get cluttered with lots of output. The clear command wipes the screen and gives you a fresh start:</p> <pre><code>clear\n</code></pre> <p>Or use the keyboard shortcut:</p> <pre><code>Ctrl+L\n</code></pre> <p>Both do the same thing. The history is still there\u2014you just can't see the old output anymore. It's like erasing a whiteboard but keeping your notes in a notebook.</p> <p>Clear vs Reset</p> <p>If <code>clear</code> doesn't seem to work properly (weird characters, broken display), try:</p> <pre><code>reset\n</code></pre> <p>This fully resets the terminal to its default state. It's the \"have you tried turning it off and on again\" of terminals.</p>"},{"location":"chapters/02-terminal-basics/#the-exit-command","title":"The Exit Command","text":"<p>When you're done with a terminal session, you can close it with the exit command:</p> <pre><code>exit\n</code></pre> <p>Or use the keyboard shortcut:</p> <pre><code>Ctrl+D\n</code></pre> <p>This closes the current shell session. If you're:</p> <ul> <li>In a terminal window \u2192 The window closes</li> <li>SSH'd into a server \u2192 You disconnect</li> <li>In a nested shell \u2192 You return to the parent shell</li> </ul> <p>Multiple Exit Levels</p> <p>Sometimes you might be \"nested\" multiple shells deep (like if you ran <code>bash</code> inside bash). Each <code>exit</code> takes you up one level. Keep typing <code>exit</code> until the window closes or you're where you want to be.</p>"},{"location":"chapters/02-terminal-basics/#shell-types-login-interactive-and-non-interactive","title":"Shell Types: Login, Interactive, and Non-Interactive","text":"<p>Not all shell sessions are created equal! Understanding shell types helps you know when certain configuration files are loaded.</p>"},{"location":"chapters/02-terminal-basics/#login-shell","title":"Login Shell","text":"<p>A login shell is the first shell that runs when you log into a system. It's called \"login\" because you had to authenticate (enter username/password) to get it.</p> <p>Login shells read special startup files like <code>~/.bash_profile</code> or <code>~/.profile</code>.</p> <p>Examples of login shells:</p> <ul> <li>Logging into a Linux console (no GUI)</li> <li>SSH'ing into a remote server</li> <li>Opening Terminal on macOS (technically)</li> </ul>"},{"location":"chapters/02-terminal-basics/#interactive-shell","title":"Interactive Shell","text":"<p>An interactive shell is any shell that's connected to a terminal and waiting for your input. You type, it responds\u2014that's \"interactive.\"</p> <p>Interactive shells read <code>~/.bashrc</code> (for Bash) or <code>~/.zshrc</code> (for Zsh).</p> <p>Examples:</p> <ul> <li>Opening a terminal window</li> <li>Running <code>bash</code> from another shell</li> </ul>"},{"location":"chapters/02-terminal-basics/#non-interactive-shell","title":"Non-Interactive Shell","text":"<p>A non-interactive shell runs without user input\u2014typically executing a script. You don't type anything; the shell just runs commands from a file.</p> <p>Examples:</p> <ul> <li>Running a shell script: <code>./myscript.sh</code></li> <li>Cron jobs (scheduled tasks)</li> <li>Commands run via SSH without a terminal: <code>ssh server 'ls -la'</code></li> </ul> Shell Type You Type Commands? Reads ~/.bashrc? Example Login + Interactive Yes Yes (usually) SSH login, console login Non-Login + Interactive Yes Yes Opening terminal in GUI Non-Login + Non-Interactive No No Running a script <p>Why Does This Matter?</p> <p>If you add something to <code>~/.bashrc</code> and it doesn't seem to work when you SSH in, it might be because SSH creates a login shell that reads <code>~/.bash_profile</code> instead. We'll cover configuration files in detail in Chapter 11!</p>"},{"location":"chapters/02-terminal-basics/#diagram-shell-types-flowchart","title":"Diagram: Shell Types Flowchart","text":"<pre><code>&lt;summary&gt;Shell Types Decision Flowchart&lt;/summary&gt;\nType: workflow\n\nBloom Taxonomy: Analyze\nLearning Objective: Help students determine what type of shell they're using and which configuration files will be loaded.\n\nVisual style: Flowchart with decision diamonds and outcome rectangles\n\nSteps:\n1. Start: \"How was the shell started?\"\n\n2. Decision: \"Did you log in (enter password)?\"\n   - Yes \u2192 \"LOGIN SHELL\" label\n   - No \u2192 Continue\n\n3. Decision: \"Can you type commands interactively?\"\n   - Yes \u2192 \"INTERACTIVE SHELL\" label\n   - No \u2192 \"NON-INTERACTIVE SHELL\" label\n\n4. Outcome boxes showing config files:\n   - Login + Interactive: \"Reads: /etc/profile, ~/.bash_profile, ~/.bashrc\"\n   - Non-Login + Interactive: \"Reads: ~/.bashrc\"\n   - Non-Interactive: \"Reads: Nothing (usually), uses BASH_ENV if set\"\n\nExamples alongside each outcome:\n- Login: SSH to server, console login\n- Interactive: Open terminal app in GUI\n- Non-Interactive: Run script, cron job\n\nColor coding:\n- Decision diamonds: Yellow\n- Login shells: Blue\n- Interactive: Green\n- Non-Interactive: Gray\n- Config file boxes: Orange\n\nImplementation: Mermaid or HTML/CSS\n</code></pre>"},{"location":"chapters/02-terminal-basics/#putting-it-all-together","title":"Putting It All Together","text":"<p>Let's practice combining everything we've learned. Try these exercises in your terminal!</p>"},{"location":"chapters/02-terminal-basics/#exercise-1-explore-your-prompt","title":"Exercise 1: Explore Your Prompt","text":"<pre><code># What's your username?\nwhoami\n\n# What's your hostname?\nhostname\n\n# What shell are you using?\necho $SHELL\n\n# What's your current directory?\npwd\n</code></pre>"},{"location":"chapters/02-terminal-basics/#exercise-2-command-syntax-practice","title":"Exercise 2: Command Syntax Practice","text":"<pre><code># List files (no options)\nls\n\n# List files with details\nls -l\n\n# List ALL files (including hidden) with details\nls -la\n\n# List with human-readable sizes\nls -lh\n\n# Combine them all!\nls -lah\n</code></pre>"},{"location":"chapters/02-terminal-basics/#exercise-3-tab-completion-speed-run","title":"Exercise 3: Tab Completion Speed Run","text":"<pre><code># Try completing these (type just what's shown, then Tab):\n# cd /h&lt;Tab&gt;/[your username first letters]&lt;Tab&gt;\n# cat /et&lt;Tab&gt;/hos&lt;Tab&gt;\n# ls /us&lt;Tab&gt;/bi&lt;Tab&gt;\n</code></pre>"},{"location":"chapters/02-terminal-basics/#exercise-4-history-navigation","title":"Exercise 4: History Navigation","text":"<pre><code># Type a few commands\necho \"Hello World\"\ndate\ncal\nls -la\n\n# Now navigate with arrows\n# Press Up, Up, Up, Down, Enter\n</code></pre>"},{"location":"chapters/02-terminal-basics/#exercise-5-keyboard-shortcuts","title":"Exercise 5: Keyboard Shortcuts","text":"<pre><code># Type a long command but don't press Enter:\necho \"This is a very long command that I am typing\"\n\n# Now try:\n# Ctrl+A - go to beginning\n# Ctrl+E - go to end\n# Ctrl+U - delete all\n# Ctrl+L - clear screen\n# Ctrl+C - cancel command\n</code></pre>"},{"location":"chapters/02-terminal-basics/#key-takeaways","title":"Key Takeaways","text":"<p>You've learned a LOT in this chapter! Let's recap:</p> <ul> <li>The shell is a program that interprets your commands (Bash, Zsh)</li> <li>The terminal emulator is the window that displays the shell</li> <li>The command line interface (CLI) is text-based input/output</li> <li>Command syntax follows the pattern: <code>command [options] [arguments]</code></li> <li>Options/flags modify command behavior (<code>-l</code>, <code>--all</code>)</li> <li>Tab completion auto-completes commands and filenames (USE IT!)</li> <li>Command history saves your previous commands (Up Arrow, <code>history</code>, Ctrl+R)</li> <li>Ctrl shortcuts make you faster (Ctrl+C, Ctrl+L, Ctrl+R, etc.)</li> <li>Shell types affect which config files are loaded</li> </ul> <p>You're a Terminal User Now!</p> <p>Congratulations! You've taken your first steps into the command line. These skills\u2014tab completion, history, shortcuts\u2014will save you HOURS over your Linux journey. Practice them until they become muscle memory!</p>"},{"location":"chapters/02-terminal-basics/#whats-next","title":"What's Next?","text":"<p>Now that you can navigate the terminal, it's time to learn actual commands! In the next chapter, you'll master:</p> <ul> <li>Moving around the file system (<code>cd</code>, <code>pwd</code>)</li> <li>Listing and viewing files (<code>ls</code>, <code>cat</code>, <code>less</code>)</li> <li>Understanding the Linux directory structure</li> <li>Working with paths (absolute vs relative)</li> </ul> <p>The terminal is your spaceship, and you've just learned the controls. Time to explore the galaxy!</p> Quick Quiz: Test Your Terminal Knowledge! <ol> <li>What's the difference between a shell and a terminal emulator?</li> <li>What key do you press to auto-complete a command or filename?</li> <li>How do you run the previous command again?</li> <li>What does Ctrl+C do?</li> <li>In <code>ls -la /home</code>, which part is the option and which is the argument?</li> </ol> Quiz Answers <ol> <li>The shell interprets commands (Bash, Zsh); the terminal emulator is the window that displays the shell</li> <li>Tab key</li> <li>Press Up Arrow and Enter, or type <code>!!</code> and Enter</li> <li>Cancels/kills the current command</li> <li><code>-la</code> is the option(s), <code>/home</code> is the argument</li> </ol>"},{"location":"chapters/03-shell-commands/","title":"Basic Shell Commands and Help Systems","text":""},{"location":"chapters/03-shell-commands/#summary","title":"Summary","text":"<p>This chapter teaches you how to find help and use fundamental shell commands. You'll master the man pages system, learn to use help commands effectively, and practice essential utilities like echo, date, and system information commands. Knowing how to find answers independently is one of the most valuable skills for any Linux user.</p>"},{"location":"chapters/03-shell-commands/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 13 concepts from the learning graph:</p> <ol> <li>Man Pages</li> <li>Help Command</li> <li>Whatis Command</li> <li>Apropos Command</li> <li>Echo Command</li> <li>Printf Command</li> <li>Date Command</li> <li>Cal Command</li> <li>Uptime Command</li> <li>Whoami Command</li> <li>Hostname Command</li> <li>Uname Command</li> <li>Version Information</li> </ol>"},{"location":"chapters/03-shell-commands/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 2: Getting Started with the Terminal</li> </ul>"},{"location":"chapters/03-shell-commands/#rtfm-the-art-of-finding-answers","title":"RTFM: The Art of Finding Answers","text":"<p>There's an old joke in the Linux community: when beginners ask questions on forums, they sometimes get a not-so-friendly response of \"RTFM!\" which stands for \"Read The Fantastic Manual\" (okay, the F word might be different, but let's keep it PG).</p> <p>While that response isn't very welcoming, there's wisdom hidden in it: Linux has an AMAZING built-in documentation system. Unlike some software where you have to Google everything and hope for a Stack Overflow answer, Linux has comprehensive help available right at your fingertips, even when you're offline.</p> <p>In this chapter, you'll learn:</p> <ul> <li>How to access Linux's built-in documentation (it's like having Wikipedia for commands)</li> <li>Essential commands for getting system information</li> <li>Basic output commands for displaying text</li> <li>How to be self-sufficient in finding answers</li> </ul> <p>By the end of this chapter, you'll rarely need to Google \"how to use [command] in Linux\" again. Let's get started!</p> <p>The Best Linux Users Know How to Find Answers</p> <p>Nobody memorizes every command and every option. The best Linux users are great at finding information, not memorizing everything. Learn the help systems in this chapter, and you'll have superpowers!</p>"},{"location":"chapters/03-shell-commands/#man-pages-your-built-in-encyclopedia","title":"Man Pages: Your Built-In Encyclopedia","text":"<p>The man pages (short for \"manual pages\") are Linux's comprehensive documentation system. Almost every command has a man page that explains:</p> <ul> <li>What the command does</li> <li>How to use it</li> <li>All available options and flags</li> <li>Examples and related commands</li> </ul> <p>To read a man page, type <code>man</code> followed by the command name:</p> <pre><code>man ls\n</code></pre> <p>This opens the manual page for the <code>ls</code> command. You'll see something like:</p> <pre><code>LS(1)                     User Commands                    LS(1)\n\nNAME\n       ls - list directory contents\n\nSYNOPSIS\n       ls [OPTION]... [FILE]...\n\nDESCRIPTION\n       List information about the FILEs (the current directory\n       by default).  Sort entries alphabetically if none of\n       -cftuvSUX nor --sort is specified.\n...\n</code></pre>"},{"location":"chapters/03-shell-commands/#navigating-man-pages","title":"Navigating Man Pages","text":"<p>Man pages use a program called <code>less</code> to display content. Here's how to navigate:</p> Key Action <code>Space</code> or <code>Page Down</code> Go forward one page <code>b</code> or <code>Page Up</code> Go back one page <code>\u2191</code> / <code>\u2193</code> Scroll one line <code>/search_term</code> Search for \"search_term\" <code>n</code> Go to next search match <code>N</code> Go to previous search match <code>q</code> Quit the man page <code>h</code> Show help for navigation <p>Man Pages are Searchable!</p> <p>When viewing a man page, press <code>/</code> and type a word to search for it. This is super helpful in long man pages. Press <code>n</code> to jump to the next occurrence, <code>N</code> for previous.</p>"},{"location":"chapters/03-shell-commands/#understanding-man-page-sections","title":"Understanding Man Page Sections","text":"<p>Man pages are organized into numbered sections for different types of documentation:</p> Section Content 1 User commands (what you'll use most) 2 System calls (programming) 3 Library functions (programming) 4 Special files (devices) 5 File formats and conventions 6 Games (yes, really!) 7 Miscellaneous 8 System administration commands <p>Sometimes the same word has man pages in multiple sections. For example, <code>printf</code> exists as both a command (section 1) and a C library function (section 3):</p> <pre><code>man 1 printf    # The shell command\nman 3 printf    # The C programming function\n</code></pre> <p>You can see which sections are available with:</p> <pre><code>man -f printf\n# or\nwhatis printf\n</code></pre>"},{"location":"chapters/03-shell-commands/#anatomy-of-a-man-page","title":"Anatomy of a Man Page","text":"<p>Every man page follows a similar structure:</p> <pre><code>NAME        - Command name and one-line description\nSYNOPSIS    - How to use the command (syntax)\nDESCRIPTION - Detailed explanation of what it does\nOPTIONS     - All the flags and options explained\nEXAMPLES    - Usage examples (not all man pages have this)\nSEE ALSO    - Related commands and man pages\nBUGS        - Known issues (surprisingly honest!)\nAUTHOR      - Who wrote it\n</code></pre> <p>The SYNOPSIS section uses special formatting:</p> <ul> <li><code>[ ]</code> brackets = optional</li> <li><code>...</code> = can be repeated</li> <li><code>|</code> = or (choose one)</li> <li>bold or CAPS = type exactly as shown</li> <li>italic or underlined = replace with your own value</li> </ul> <p>Example from <code>ls</code>: <pre><code>ls [OPTION]... [FILE]...\n</code></pre></p> <p>This means: type <code>ls</code>, optionally add options, optionally add one or more files.</p>"},{"location":"chapters/03-shell-commands/#diagram-man-page-anatomy","title":"Diagram: Man Page Anatomy","text":"<pre><code>&lt;summary&gt;Anatomy of a Man Page&lt;/summary&gt;\nType: diagram\n\nBloom Taxonomy: Understand\nLearning Objective: Help students understand the structure of man pages so they can quickly find the information they need.\n\nComponents to show:\n- A stylized man page with labeled sections\n- Color-coded sections: NAME, SYNOPSIS, DESCRIPTION, OPTIONS, EXAMPLES, SEE ALSO\n- Callout boxes explaining what each section contains\n- Highlight the most useful sections for beginners (NAME, SYNOPSIS, OPTIONS)\n\nLayout: Vertical document representation with colored section headers\n\nAnnotations:\n- NAME: \"Quick summary - is this the right command?\"\n- SYNOPSIS: \"The command pattern - how to use it\"\n- DESCRIPTION: \"The full explanation - read when confused\"\n- OPTIONS: \"All the flags explained - your go-to reference\"\n- EXAMPLES: \"Copy-paste gold! (when available)\"\n- SEE ALSO: \"Related commands to explore\"\n\nColor scheme:\n- Section headers: Blue\n- Most useful sections: Green highlight\n- Programming sections: Gray (less relevant for beginners)\n\nInteractive features:\n- Click on each section to see example content\n- Hover for tips on how to use that section\n\nImplementation: HTML/CSS or p5.js\n</code></pre>"},{"location":"chapters/03-shell-commands/#the-help-command-quick-reference","title":"The Help Command: Quick Reference","text":"<p>Many commands have a built-in help command that provides a shorter summary than the full man page. There are two ways to access this:</p>"},{"location":"chapters/03-shell-commands/#using-help-flag","title":"Using --help Flag","text":"<p>Most GNU commands support the <code>--help</code> flag:</p> <pre><code>ls --help\n</code></pre> <p>This prints help information directly to your terminal (no pager needed). It's usually shorter and more to-the-point than the man page.</p> <pre><code>cp --help        # Help for cp command\nmkdir --help     # Help for mkdir command\ngrep --help      # Help for grep command\n</code></pre>"},{"location":"chapters/03-shell-commands/#using-the-help-built-in","title":"Using the help Built-in","text":"<p>For shell built-in commands (commands that are part of bash itself, not separate programs), use the <code>help</code> command:</p> <pre><code>help cd          # Help for cd (built-in)\nhelp history     # Help for history (built-in)\nhelp alias       # Help for alias (built-in)\n</code></pre> <p>How to Know If Something is Built-in</p> <p>Use the <code>type</code> command: <pre><code>type cd       # cd is a shell builtin\ntype ls       # ls is /bin/ls\n</code></pre> Built-ins use <code>help</code>, external commands use <code>--help</code> or <code>man</code>.</p>"},{"location":"chapters/03-shell-commands/#when-to-use-which","title":"When to Use Which?","text":"Help Method Best For Speed <code>command --help</code> Quick reference, external commands Fast <code>help command</code> Shell built-ins Fast <code>man command</code> Full documentation, examples Detailed <p>My typical workflow: 1. Try <code>--help</code> first for a quick answer 2. If that doesn't help, dive into <code>man</code> 3. For built-ins, use <code>help</code></p>"},{"location":"chapters/03-shell-commands/#whatis-the-one-line-summary","title":"Whatis: The One-Line Summary","text":"<p>The whatis command gives you a one-line description of what a command does. It's perfect when you vaguely remember a command name but forgot what it does.</p> <pre><code>whatis ls\n# ls (1)     - list directory contents\n\nwhatis grep\n# grep (1)   - print lines that match patterns\n\nwhatis cat\n# cat (1)    - concatenate files and print on the standard output\n</code></pre> <p>You can even check multiple commands at once:</p> <pre><code>whatis ls cat cp mv rm\n</code></pre> <p>Think of <code>whatis</code> as the \"elevator pitch\" for a command\u2014just enough info to know if it's what you're looking for.</p> <p>Behind the Scenes</p> <p><code>whatis</code> reads from the same database as <code>man -f</code>. If you get \"nothing appropriate,\" the man database might need to be updated (run <code>sudo mandb</code> on Debian/Ubuntu).</p>"},{"location":"chapters/03-shell-commands/#apropos-finding-commands-you-forgot","title":"Apropos: Finding Commands You Forgot","text":"<p>What if you know WHAT you want to do, but you can't remember the command name? Apropos to the rescue!</p> <p>The apropos command searches man page descriptions for a keyword:</p> <pre><code>apropos \"copy files\"\n# cp (1)     - copy files and directories\n\napropos calendar\n# cal (1)    - display a calendar\n# ncal (1)   - display a calendar\n\napropos \"disk space\"\n# df (1)     - report file system disk space usage\n# du (1)     - estimate file space usage\n</code></pre> <p>This is like having a search engine for Linux commands! Some practical examples:</p> <pre><code>apropos compress     # How do I compress files?\napropos permission   # How do I change permissions?\napropos network      # What commands deal with networking?\napropos text         # Commands for text manipulation\n</code></pre> <p>Pro Tip: Use Apropos When Stuck</p> <p>Can't remember the command? Think of a keyword that describes what you want, and <code>apropos</code> it! It's much faster than Googling \"how to [do thing] in Linux.\"</p> <p>You can also use <code>man -k</code> which does the same thing:</p> <pre><code>man -k calendar      # Same as: apropos calendar\n</code></pre>"},{"location":"chapters/03-shell-commands/#diagram-help-system-decision-tree","title":"Diagram: Help System Decision Tree","text":"<pre><code>&lt;summary&gt;Which Help Command Should I Use?&lt;/summary&gt;\n</code></pre> <p>Type: workflow</p> <p>Bloom Taxonomy: Apply, Analyze Learning Objective: Help students quickly determine which help system to use based on their situation.</p> <p>Visual style: Flowchart with decision diamonds</p> <p>Steps: 1. Start: \"I need help with a Linux command\"</p> <ol> <li> <p>Decision: \"Do you know the command name?\"</p> <ul> <li>Yes \u2192 Go to step 3</li> <li>No \u2192 \"Use: apropos [keyword]\"</li> </ul> </li> <li> <p>Decision: \"How much detail do you need?\"</p> <ul> <li>Just a reminder \u2192 Go to step 4</li> <li>Full documentation \u2192 \"Use: man [command]\"</li> </ul> </li> <li> <p>Decision: \"Is it a shell built-in?\"</p> <ul> <li>Yes \u2192 \"Use: help [command]\"</li> <li>No/Unsure \u2192 \"Use: command --help\"</li> </ul> </li> </ol> <p>Additional paths: - \"Want one-line summary?\" \u2192 \"Use: whatis [command]\" - \"Check if built-in?\" \u2192 \"Use: type [command]\"</p> <p>Color coding: - Decision diamonds: Yellow - apropos: Blue (discovery) - man: Green (comprehensive) - --help/help: Orange (quick reference) - whatis: Purple (summary)</p> <p>Example outcomes shown: - apropos \u2192 <code>apropos compress</code> \u2192 finds compression commands - man \u2192 <code>man tar</code> \u2192 full tar documentation - --help \u2192 <code>ls --help</code> \u2192 quick ls reference</p> <p>Implementation: Mermaid or HTML/CSS</p>"},{"location":"chapters/03-shell-commands/#echo-making-the-terminal-talk","title":"Echo: Making the Terminal Talk","text":"<p>The echo command is one of the simplest and most useful commands in Linux. It does exactly what its name suggests\u2014it echoes back whatever you give it.</p> <pre><code>echo Hello World\n# Hello World\n\necho \"I am learning Linux!\"\n# I am learning Linux!\n</code></pre>"},{"location":"chapters/03-shell-commands/#why-is-echo-useful","title":"Why is Echo Useful?","text":"<p>Echo might seem boring, but it's incredibly useful for:</p> <ol> <li> <p>Displaying variable values <pre><code>echo $HOME\n# /home/dan\n\necho $USER\n# dan\n\necho $PATH\n# /usr/local/bin:/usr/bin:/bin:...\n</code></pre></p> </li> <li> <p>Writing to files <pre><code>echo \"Hello\" &gt; file.txt       # Write (overwrites)\necho \"World\" &gt;&gt; file.txt      # Append\n</code></pre></p> </li> <li> <p>In shell scripts (you'll learn these later!) <pre><code>echo \"Starting backup...\"\necho \"Backup complete!\"\n</code></pre></p> </li> <li> <p>Quick text manipulation <pre><code>echo \"Hello\" | wc -c          # Count characters in \"Hello\"\n</code></pre></p> </li> </ol>"},{"location":"chapters/03-shell-commands/#echo-options","title":"Echo Options","text":"<p>Echo has a few handy options:</p> <pre><code># -n: No newline at the end\necho -n \"Enter your name: \"\n# Cursor stays on same line\n\n# -e: Enable escape sequences\necho -e \"Line 1\\nLine 2\\nLine 3\"\n# Line 1\n# Line 2\n# Line 3\n\necho -e \"Tab:\\tSeparated\"\n# Tab:    Separated\n\necho -e \"\\a\"\n# Makes a beep! (if your terminal supports it)\n</code></pre> <p>Common escape sequences with <code>-e</code>:</p> Escape Meaning <code>\\n</code> Newline <code>\\t</code> Tab <code>\\\\</code> Backslash <code>\\a</code> Alert (beep) <p>Quotes Matter with Echo</p> <p><pre><code>echo Hello     World     # Prints: Hello World (extra spaces gone)\necho \"Hello     World\"   # Prints: Hello     World (spaces preserved)\n</code></pre> Use quotes to preserve spacing and special characters!</p>"},{"location":"chapters/03-shell-commands/#printf-echos-sophisticated-cousin","title":"Printf: Echo's Sophisticated Cousin","text":"<p>The printf command is like <code>echo</code> but with superpowers. It gives you precise control over formatting, similar to the printf function in C programming.</p> <pre><code>printf \"Hello, World!\\n\"\n# Hello, World!\n</code></pre> <p>Notice that <code>printf</code> doesn't add a newline automatically\u2014you need to include <code>\\n</code> yourself.</p>"},{"location":"chapters/03-shell-commands/#format-specifiers","title":"Format Specifiers","text":"<p>Printf uses format specifiers to insert values:</p> <pre><code>printf \"Name: %s\\n\" \"Alice\"\n# Name: Alice\n\nprintf \"Age: %d years old\\n\" 25\n# Age: 25 years old\n\nprintf \"Price: $%.2f\\n\" 19.99\n# Price: $19.99\n</code></pre> Specifier Type Example <code>%s</code> String <code>printf \"%s\" \"hello\"</code> <code>%d</code> Integer <code>printf \"%d\" 42</code> <code>%f</code> Float <code>printf \"%.2f\" 3.14159</code> <code>%x</code> Hexadecimal <code>printf \"%x\" 255</code> \u2192 ff <code>%%</code> Literal % <code>printf \"100%%\"</code>"},{"location":"chapters/03-shell-commands/#formatting-numbers","title":"Formatting Numbers","text":"<p>Printf really shines when you need formatted output:</p> <pre><code># Padding numbers with zeros\nprintf \"%05d\\n\" 42\n# 00042\n\n# Aligning columns\nprintf \"%-10s %5d\\n\" \"Apples\" 5\nprintf \"%-10s %5d\\n\" \"Oranges\" 12\nprintf \"%-10s %5d\\n\" \"Bananas\" 100\n# Apples         5\n# Oranges       12\n# Bananas      100\n\n# Currency formatting\nprintf \"$%'.2f\\n\" 1234567.89\n# $1,234,567.89 (on some systems)\n</code></pre> <p>Printf is overkill for simple messages (use <code>echo</code>), but it's essential when you need precise formatting.</p>"},{"location":"chapters/03-shell-commands/#date-what-time-is-it","title":"Date: What Time Is It?","text":"<p>The date command displays the current date and time. Simple, right?</p> <pre><code>date\n# Fri Dec  6 14:30:45 PST 2025\n</code></pre> <p>But <code>date</code> is more powerful than it looks!</p>"},{"location":"chapters/03-shell-commands/#formatting-dates","title":"Formatting Dates","text":"<p>Use <code>+</code> followed by format codes to customize the output:</p> <pre><code># Just the date\ndate +%Y-%m-%d\n# 2025-12-06\n\n# Just the time\ndate +%H:%M:%S\n# 14:30:45\n\n# Day of the week\ndate +%A\n# Friday\n\n# Custom format\ndate +\"Today is %A, %B %d, %Y\"\n# Today is Friday, December 06, 2025\n</code></pre>"},{"location":"chapters/03-shell-commands/#common-date-format-codes","title":"Common Date Format Codes","text":"Code Meaning Example <code>%Y</code> 4-digit year 2025 <code>%m</code> Month (01-12) 12 <code>%d</code> Day (01-31) 06 <code>%H</code> Hour (00-23) 14 <code>%M</code> Minute (00-59) 30 <code>%S</code> Second (00-59) 45 <code>%A</code> Full weekday name Friday <code>%B</code> Full month name December <code>%a</code> Short weekday Fri <code>%b</code> Short month Dec <code>%j</code> Day of year (001-366) 341 <code>%s</code> Seconds since 1970 (Unix timestamp) 1765059045"},{"location":"chapters/03-shell-commands/#practical-date-examples","title":"Practical Date Examples","text":"<pre><code># Create a timestamp for filenames\ndate +%Y%m%d_%H%M%S\n# 20251206_143045\n\n# Use in a filename\ntouch \"backup_$(date +%Y%m%d).tar.gz\"\n\n# Show a different timezone\nTZ=\"Europe/London\" date\n# Fri Dec  6 22:30:45 GMT 2025\n\n# What day was July 4, 1776?\ndate -d \"1776-07-04\" +%A\n# Thursday\n</code></pre> <p>Timestamps for Filenames</p> <p>The format <code>%Y%m%d_%H%M%S</code> (like <code>20251206_143045</code>) is great for filenames because: - Files sort chronologically when sorted alphabetically - No spaces or special characters - Unambiguous worldwide (unlike mm/dd vs dd/mm)</p>"},{"location":"chapters/03-shell-commands/#cal-your-terminal-calendar","title":"Cal: Your Terminal Calendar","text":"<p>The cal command displays a calendar right in your terminal. It's simple but surprisingly handy!</p> <pre><code>cal\n</code></pre> <p>Shows the current month: <pre><code>   December 2025\nSu Mo Tu We Th Fr Sa\n    1  2  3  4  5  6\n 7  8  9 10 11 12 13\n14 15 16 17 18 19 20\n21 22 23 24 25 26 27\n28 29 30 31\n</code></pre></p>"},{"location":"chapters/03-shell-commands/#cal-options","title":"Cal Options","text":"<pre><code># Show entire year\ncal 2025\n\n# Show specific month and year\ncal 7 1969        # July 1969 (Moon landing!)\n\n# Show 3 months (previous, current, next)\ncal -3\n\n# Show a specific year\ncal -y 2025       # All 12 months of 2025\n\n# Week starts on Monday (European style)\ncal -m\n</code></pre>"},{"location":"chapters/03-shell-commands/#fun-cal-tricks","title":"Fun Cal Tricks","text":"<pre><code># When is Thanksgiving this year? (4th Thursday of November)\ncal 11 2025\n\n# What day of the week was I born?\ncal 3 1990        # March 1990\n\n# The famous September 1752 calendar (Britain switched to Gregorian)\ncal 9 1752\n# Notice 11 days are missing!\n</code></pre> <p>The Missing Days of 1752</p> <p>Try <code>cal 9 1752</code> and you'll see September 3-13 are missing! This is when Britain switched from the Julian to Gregorian calendar. It's historically accurate!</p>"},{"location":"chapters/03-shell-commands/#uptime-how-long-has-the-system-been-running","title":"Uptime: How Long Has the System Been Running?","text":"<p>The uptime command shows how long your system has been running since the last boot, plus some other useful info:</p> <pre><code>uptime\n# 14:30:45 up 23 days,  4:12,  2 users,  load average: 0.15, 0.10, 0.08\n</code></pre> <p>Let's decode this:</p> Part Meaning <code>14:30:45</code> Current time <code>up 23 days, 4:12</code> System has been running 23 days, 4 hours, 12 minutes <code>2 users</code> Number of logged-in users <code>load average: 0.15, 0.10, 0.08</code> CPU load over 1, 5, and 15 minutes"},{"location":"chapters/03-shell-commands/#why-uptime-matters","title":"Why Uptime Matters","text":"<ul> <li>Stability check: Servers should have high uptime</li> <li>Performance monitoring: Load averages show system stress</li> <li>Troubleshooting: \"Did the system restart recently?\"</li> </ul> <pre><code># Just the uptime, human-readable\nuptime -p\n# up 3 weeks, 2 days, 4 hours, 12 minutes\n\n# When did the system boot?\nuptime -s\n# 2025-11-13 10:18:33\n</code></pre> <p>Understanding Load Average</p> <p>The load average shows how many processes are waiting for CPU time. For a single-core CPU: - &lt; 1.0 = CPU has capacity - = 1.0 = CPU is fully utilized - &gt; 1.0 = Processes are waiting (potential bottleneck)</p> <p>For a 4-core CPU, 4.0 would be fully utilized.</p>"},{"location":"chapters/03-shell-commands/#whoami-identity-check","title":"Whoami: Identity Check","text":"<p>The whoami command is the simplest possible command\u2014it just tells you who you are:</p> <pre><code>whoami\n# dan\n</code></pre> <p>That's it! It prints your username.</p>"},{"location":"chapters/03-shell-commands/#when-is-whoami-useful","title":"When is Whoami Useful?","text":"<p>It seems trivial, but <code>whoami</code> is helpful when:</p> <ul> <li>You're logged into multiple servers and forget which user you're using</li> <li>In scripts that need to check who's running them</li> <li>After using <code>su</code> or <code>sudo -i</code> to verify you changed users</li> </ul> <pre><code># Normal user\nwhoami\n# dan\n\n# After switching to root\nsudo -i\nwhoami\n# root\n\nexit\nwhoami\n# dan (back to normal)\n</code></pre> <p>Related commands for identity:</p> <pre><code>id              # Detailed user and group info\nid -un          # Same as whoami\nwho             # All logged-in users\nw               # Who's logged in and what they're doing\n</code></pre>"},{"location":"chapters/03-shell-commands/#hostname-what-computer-is-this","title":"Hostname: What Computer Is This?","text":"<p>The hostname command tells you the name of your computer:</p> <pre><code>hostname\n# raspberry-pi\n</code></pre> <p>This is especially useful when you're SSH'd into remote servers and need to remember which machine you're on!</p>"},{"location":"chapters/03-shell-commands/#hostname-options","title":"Hostname Options","text":"<pre><code># Show hostname only\nhostname\n# mycomputer\n\n# Show fully qualified domain name (FQDN)\nhostname -f\n# mycomputer.local\n\n# Show IP address\nhostname -I\n# 192.168.1.100\n\n# Show short hostname (without domain)\nhostname -s\n# mycomputer\n</code></pre> <p>Customize Your Prompt</p> <p>Remember from Chapter 2 that your prompt shows the hostname? That's where that info comes from! Commands like <code>hostname</code> are useful in scripts, but day-to-day you'll see your hostname in the prompt.</p>"},{"location":"chapters/03-shell-commands/#uname-system-information","title":"Uname: System Information","text":"<p>The uname command (Unix name) gives you information about the operating system and hardware:</p> <pre><code>uname\n# Linux\n</code></pre> <p>By itself, it just shows the kernel name. But with options, it reveals much more:</p>"},{"location":"chapters/03-shell-commands/#uname-options","title":"Uname Options","text":"<pre><code># All information\nuname -a\n# Linux raspberry-pi 6.1.0-rpi7-rpi-v8 #1 SMP PREEMPT Debian 1:6.1.63-1+rpt1 aarch64 GNU/Linux\n\n# Kernel name\nuname -s\n# Linux\n\n# Hostname (same as hostname command)\nuname -n\n# raspberry-pi\n\n# Kernel release version\nuname -r\n# 6.1.0-rpi7-rpi-v8\n\n# Kernel version details\nuname -v\n# #1 SMP PREEMPT Debian 1:6.1.63-1+rpt1\n\n# Machine hardware type (architecture)\nuname -m\n# aarch64 (ARM 64-bit) or x86_64 (Intel/AMD 64-bit)\n\n# Processor type\nuname -p\n# aarch64\n\n# Operating system\nuname -o\n# GNU/Linux\n</code></pre>"},{"location":"chapters/03-shell-commands/#understanding-uname-a-output","title":"Understanding uname -a Output","text":"<p>Let's break down <code>uname -a</code>:</p> <pre><code>Linux raspberry-pi 6.1.0-rpi7-rpi-v8 #1 SMP PREEMPT Debian 1:6.1.63-1+rpt1 aarch64 GNU/Linux\n\u2502     \u2502            \u2502                  \u2502                                     \u2502       \u2502\n\u2502     \u2502            \u2502                  \u2502                                     \u2502       \u2514\u2500 OS name\n\u2502     \u2502            \u2502                  \u2502                                     \u2514\u2500 Architecture\n\u2502     \u2502            \u2502                  \u2514\u2500 Kernel version and build info\n\u2502     \u2502            \u2514\u2500 Kernel release\n\u2502     \u2514\u2500 Hostname\n\u2514\u2500 Kernel name\n</code></pre> <p>This tells you: - Kernel: Linux - Machine: raspberry-pi - Architecture: aarch64 (64-bit ARM processor) - Kernel Version: 6.1.0-rpi7-rpi-v8</p>"},{"location":"chapters/03-shell-commands/#version-information-whats-installed","title":"Version Information: What's Installed?","text":"<p>Getting version information is crucial for troubleshooting and ensuring compatibility. Different programs have different ways to show their version:</p>"},{"location":"chapters/03-shell-commands/#common-version-flags","title":"Common Version Flags","text":"<pre><code># Most programs use --version or -V\nbash --version\n# GNU bash, version 5.2.15(1)-release\n\npython3 --version\n# Python 3.11.4\n\ngit --version\n# git version 2.42.0\n\ngcc --version\n# gcc (Debian 12.2.0-14) 12.2.0\n\n# Some use -v\nssh -V\n# OpenSSH_9.4p1 Debian-1, OpenSSL 3.0.9\n\n# Some use -version (note: single dash)\njava -version\n# openjdk version \"17.0.9\"\n</code></pre>"},{"location":"chapters/03-shell-commands/#checking-linux-distribution-version","title":"Checking Linux Distribution Version","text":"<pre><code># Show distribution info\ncat /etc/os-release\n\n# Just the name and version\nlsb_release -a\n# Distributor ID: Debian\n# Description:    Debian GNU/Linux 12 (bookworm)\n# Release:        12\n# Codename:       bookworm\n\n# One-liner version\ncat /etc/debian_version    # Debian-based systems\n# 12.2\n</code></pre>"},{"location":"chapters/03-shell-commands/#version-microsim","title":"Version MicroSim","text":""},{"location":"chapters/03-shell-commands/#diagram-system-information-dashboard","title":"Diagram: System Information Dashboard","text":"<pre><code>&lt;summary&gt;Interactive System Information Display&lt;/summary&gt;\nType: microsim\n\nBloom Taxonomy: Remember, Apply\nLearning Objective: Help students understand what system information commands reveal and practice using them.\n\nCanvas layout (responsive, ~700px max width):\n- Top area (400px): Dashboard display showing system info\n- Bottom area (100px): Command selector\n\nVisual elements:\n- Dashboard-style display with panels for each category:\n  - User panel: whoami result, user icon\n  - Host panel: hostname result, computer icon\n  - System panel: uname -a breakdown, Linux penguin\n  - Time panel: date, uptime, clock icon\n  - Version panel: kernel version, distro info\n\nInteractive controls:\n- Dropdown: Select a command to \"run\"\n- Output area: Shows command and result\n- \"Copy command\" button\n\nCommands available:\n- whoami\n- hostname / hostname -I\n- uname -a / uname -r / uname -m\n- uptime / uptime -p\n- date / date +%Y-%m-%d\n\nBehavior:\n- Clicking a command shows its output\n- Dashboard updates with relevant panel highlighted\n- Explanation of output appears below\n\nVisual style:\n- Dark terminal aesthetic\n- Glowing green/blue accents\n- System monitoring dashboard feel\n\nImplementation: p5.js\n</code></pre>"},{"location":"chapters/03-shell-commands/#putting-it-all-together-system-report-script","title":"Putting It All Together: System Report Script","text":"<p>Let's combine what we've learned to create a mini system report:</p> <pre><code># A quick system status check\necho \"=== System Report ===\"\necho \"User: $(whoami)\"\necho \"Host: $(hostname)\"\necho \"Date: $(date)\"\necho \"\"\necho \"=== System Info ===\"\nuname -a\necho \"\"\necho \"=== Uptime ===\"\nuptime\necho \"\"\necho \"=== You're running ===\"\ncat /etc/os-release | head -2\n</code></pre> <p>Try running each line in your terminal! Later, you'll learn to save this as a script and run it with one command.</p>"},{"location":"chapters/03-shell-commands/#quick-reference-cheat-sheet","title":"Quick Reference Cheat Sheet","text":"<p>Here's a handy reference for all the commands in this chapter:</p> Command Purpose Example <code>man command</code> Full manual page <code>man ls</code> <code>command --help</code> Quick help <code>ls --help</code> <code>help command</code> Built-in help <code>help cd</code> <code>whatis command</code> One-line description <code>whatis grep</code> <code>apropos keyword</code> Find commands by keyword <code>apropos copy</code> <code>echo text</code> Print text <code>echo \"Hello\"</code> <code>printf format</code> Formatted output <code>printf \"%s\\n\" \"Hi\"</code> <code>date</code> Show date/time <code>date +%Y-%m-%d</code> <code>cal</code> Show calendar <code>cal 12 2025</code> <code>uptime</code> System uptime <code>uptime -p</code> <code>whoami</code> Current username <code>whoami</code> <code>hostname</code> Computer name <code>hostname -I</code> <code>uname -a</code> System information <code>uname -r</code>"},{"location":"chapters/03-shell-commands/#key-takeaways","title":"Key Takeaways","text":"<p>You've learned the essential skills for being a self-sufficient Linux user:</p> <ul> <li>Man pages provide comprehensive documentation for every command</li> <li>--help and help give quick summaries when you need a reminder</li> <li>whatis tells you what a command does in one line</li> <li>apropos helps you find commands when you've forgotten the name</li> <li>echo and printf display text and variables</li> <li>date and cal show time and calendar information</li> <li>uptime shows how long the system has been running</li> <li>whoami, hostname, and uname reveal identity and system information</li> <li>Version flags (<code>--version</code>, <code>-V</code>) show what software versions are installed</li> </ul> <p>You're Now Self-Sufficient!</p> <p>The most important skill from this chapter isn't any single command\u2014it's knowing HOW TO FIND HELP. With <code>man</code>, <code>--help</code>, <code>whatis</code>, and <code>apropos</code>, you can figure out almost any Linux command on your own. That's real power!</p>"},{"location":"chapters/03-shell-commands/#whats-next","title":"What's Next?","text":"<p>Now that you can find help and check basic system information, it's time to learn about the most important concept in Linux: the file system! In the next chapter, you'll discover:</p> <ul> <li>How Linux organizes files (hint: everything is a file!)</li> <li>Navigating with <code>cd</code> and <code>pwd</code></li> <li>The difference between absolute and relative paths</li> <li>Important directories like <code>/home</code>, <code>/etc</code>, and <code>/var</code></li> </ul> <p>The foundation is set. Let's explore the file system!</p> Quick Quiz: Help Systems and Basic Commands <ol> <li>What command shows the full documentation for <code>ls</code>?</li> <li>How do you search for commands related to \"compress\"?</li> <li>What's the difference between <code>echo</code> and <code>printf</code>?</li> <li>How do you display just the kernel version?</li> <li>What command shows how long the system has been running?</li> </ol> Quiz Answers <ol> <li><code>man ls</code></li> <li><code>apropos compress</code> or <code>man -k compress</code></li> <li><code>echo</code> automatically adds a newline and is simpler; <code>printf</code> gives precise formatting control</li> <li><code>uname -r</code></li> <li><code>uptime</code> (or <code>uptime -p</code> for human-readable format)</li> </ol>"},{"location":"chapters/04-file-system/","title":"File System Fundamentals","text":""},{"location":"chapters/04-file-system/#summary","title":"Summary","text":"<p>This chapter explores the Linux file system hierarchy, teaching you how everything in Linux is organized as files and directories. You'll learn to navigate using absolute and relative paths, understand the purpose of key system directories like /bin, /etc, and /home, and master essential navigation commands. Understanding the file system is crucial for working effectively in Linux.</p>"},{"location":"chapters/04-file-system/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 32 concepts from the learning graph:</p> <ol> <li>File System</li> <li>Root Directory</li> <li>Home Directory</li> <li>Current Directory</li> <li>Parent Directory</li> <li>Absolute Path</li> <li>Relative Path</li> <li>Pwd Command</li> <li>Cd Command</li> <li>Ls Command</li> <li>Ls Options</li> <li>Hidden Files</li> <li>Dot Files</li> <li>Directory Structure</li> <li>Bin Directory</li> <li>Etc Directory</li> <li>Var Directory</li> <li>Tmp Directory</li> <li>Usr Directory</li> <li>Opt Directory</li> <li>Dev Directory</li> <li>Proc Directory</li> <li>Home Subdirectories</li> <li>Desktop Directory</li> <li>Documents Directory</li> <li>Downloads Directory</li> <li>Tree Command</li> <li>File Command</li> <li>Stat Command</li> <li>Pathnames</li> <li>macOS open command</li> <li>Open alias on Linux</li> </ol>"},{"location":"chapters/04-file-system/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 1: Introduction to Operating Systems and UNIX History</li> <li>Chapter 2: Getting Started with the Terminal</li> </ul>"},{"location":"chapters/04-file-system/#everything-is-a-file-no-really","title":"Everything Is a File (No, Really!)","text":"<p>One of the most mind-bending things about Linux is its philosophy that everything is a file. Not just your documents and photos\u2014EVERYTHING:</p> <ul> <li>Regular files? Files. \u2713</li> <li>Directories? Special files that contain other files. \u2713</li> <li>Your keyboard? A file. \u2713</li> <li>Your screen? A file. \u2713</li> <li>Your USB drive? A file. \u2713</li> <li>Network connections? Files. \u2713</li> <li>Running processes? Files. \u2713</li> </ul> <p>This might sound weird, but it's actually brilliant. Because everything is accessed the same way, you can use the same tools and concepts for nearly everything in the system. Learn to work with files, and you've learned to work with Linux.</p> <p>In this chapter, we'll explore how Linux organizes its file system\u2014the structure that holds all these files. Think of it as learning the layout of a new city. Once you know the neighborhoods and how the streets connect, you can get anywhere!</p> <p>Why File System Knowledge Matters</p> <p>Understanding the file system is like having a map. Without it, you're wandering aimlessly, guessing where things are. With it, you'll know exactly where to find configuration files, executables, logs, and your own data.</p>"},{"location":"chapters/04-file-system/#the-root-of-all-files","title":"The Root of All Files: /","text":"<p>Every Linux file system starts at a single point called the root directory, written as just a forward slash: <code>/</code></p> <p>This is the top of the tree\u2014the ultimate parent directory that contains everything else. Unlike Windows, which has separate drives (C:, D:, E:), Linux has ONE unified tree starting at root. Everything\u2014every file, every device, every directory\u2014lives somewhere under <code>/</code>.</p> <pre><code>/                   \u2190 The root directory (top of everything)\n\u251c\u2500\u2500 bin/            \u2190 Essential commands\n\u251c\u2500\u2500 etc/            \u2190 System configuration\n\u251c\u2500\u2500 home/           \u2190 User home directories\n\u2502   \u251c\u2500\u2500 dan/        \u2190 Dan's home\n\u2502   \u2514\u2500\u2500 alice/      \u2190 Alice's home\n\u251c\u2500\u2500 tmp/            \u2190 Temporary files\n\u251c\u2500\u2500 usr/            \u2190 User programs\n\u251c\u2500\u2500 var/            \u2190 Variable data (logs, etc.)\n\u2514\u2500\u2500 ...             \u2190 Many more directories\n</code></pre> <p>Root Directory vs Root User</p> <p>Don't confuse them! The root directory (<code>/</code>) is the top of the file system. The root user is the administrator account. They share a name because root user's home directory is <code>/root</code> (a directory INSIDE the root directory). Confusing? A little. Just remember: <code>/</code> = file system top, <code>root</code> = admin user.</p>"},{"location":"chapters/04-file-system/#home-sweet-home-your-home-directory","title":"Home Sweet Home: Your Home Directory","text":"<p>While the root directory contains the whole system, your home directory is your personal space. It's where:</p> <ul> <li>Your personal files live (Documents, Downloads, Pictures)</li> <li>Your configuration files are stored</li> <li>You have full permission to create, modify, and delete files</li> </ul> <p>Your home directory is located at <code>/home/username</code>. So if your username is \"dan\", your home is <code>/home/dan</code>.</p> <p>There's a super handy shortcut for your home directory: the tilde character <code>~</code></p> <pre><code># These are all equivalent for user \"dan\":\ncd /home/dan\ncd ~\ncd $HOME\ncd          # Just \"cd\" with no arguments goes home!\n</code></pre> <p>The <code>~</code> is incredibly useful:</p> <pre><code># Go to your Documents folder\ncd ~/Documents\n\n# Copy a file to your home directory\ncp somefile.txt ~\n\n# List files in your Desktop\nls ~/Desktop\n</code></pre>"},{"location":"chapters/04-file-system/#home-subdirectories","title":"Home Subdirectories","text":"<p>Most Linux systems create standard folders in your home directory:</p> Directory Purpose Desktop Files/folders shown on your desktop GUI Documents General documents Downloads Downloaded files (browsers save here by default) Music Audio files Pictures Images and photos Videos Video files Templates Document templates Public Files you want to share with other users <p>These are just conventions\u2014you can organize your files however you like! But many programs expect these directories to exist.</p>"},{"location":"chapters/04-file-system/#where-am-i-the-current-directory","title":"Where Am I? The Current Directory","text":"<p>At any moment, your terminal is \"in\" a specific directory called the current directory (also called \"working directory\" or \"present working directory\"). When you run commands, they operate relative to this location.</p> <p>The pwd command (Print Working Directory) tells you where you are:</p> <pre><code>pwd\n# /home/dan/Documents\n</code></pre> <p>That's it! <code>pwd</code> is your \"You Are Here\" marker on the file system map.</p> <p>Your shell prompt usually shows the current directory too:</p> <pre><code>dan@raspberry:~/Documents$\n#             \u2191 This shows current directory\n</code></pre> <p>Lost? Just pwd!</p> <p>Whenever you're not sure where you are in the file system, type <code>pwd</code>. It's the command-line equivalent of looking at the GPS on your phone.</p>"},{"location":"chapters/04-file-system/#moving-around-the-cd-command","title":"Moving Around: The cd Command","text":"<p>The cd command (Change Directory) is how you move through the file system. It's like walking from one room to another in a building.</p> <pre><code># Go to a specific directory\ncd /home/dan/Documents\n\n# Go to your home directory\ncd ~\n# or just\ncd\n\n# Go to the root directory\ncd /\n\n# Go up one level (to parent directory)\ncd ..\n\n# Go back to the previous directory\ncd -\n</code></pre>"},{"location":"chapters/04-file-system/#the-parent-directory","title":"The Parent Directory: ..","text":"<p>The parent directory is the directory that contains the current one. It's represented by two dots: <code>..</code></p> <pre><code>/home/dan/Documents/Projects\n       \u2191                \u2191\n       \u2514\u2500\u2500 Parent of \u2500\u2500\u2500\u2518\n</code></pre> <p>So if you're in <code>/home/dan/Documents/Projects</code>:</p> <pre><code>pwd\n# /home/dan/Documents/Projects\n\ncd ..\npwd\n# /home/dan/Documents\n\ncd ..\npwd\n# /home/dan\n\ncd ..\npwd\n# /home\n\ncd ..\npwd\n# /\n</code></pre> <p>You can chain <code>..</code> to go up multiple levels:</p> <pre><code>cd ../..        # Go up two levels\ncd ../../..     # Go up three levels\n</code></pre>"},{"location":"chapters/04-file-system/#the-current-directory","title":"The Current Directory: .","text":"<p>A single dot <code>.</code> represents the current directory. It seems pointless (\"I'm already here!\"), but it's useful in certain contexts:</p> <pre><code># Run a script in the current directory\n./myscript.sh\n\n# Copy files TO the current directory\ncp /some/file.txt .\n\n# List the current directory explicitly\nls .\n</code></pre>"},{"location":"chapters/04-file-system/#absolute-vs-relative-paths","title":"Absolute vs Relative Paths","text":"<p>Here's a crucial concept: there are two ways to specify a location in the file system.</p>"},{"location":"chapters/04-file-system/#absolute-paths","title":"Absolute Paths","text":"<p>An absolute path starts from the root directory <code>/</code> and specifies the complete location:</p> <pre><code>/home/dan/Documents/report.txt\n/etc/passwd\n/usr/bin/python3\n</code></pre> <p>Absolute paths work from anywhere\u2014they're like giving a complete street address.</p>"},{"location":"chapters/04-file-system/#relative-paths","title":"Relative Paths","text":"<p>A relative path starts from your current directory:</p> <pre><code># If you're in /home/dan:\nDocuments/report.txt     # Relative to where you are\n../alice/photos          # Go up, then into alice, then photos\n./script.sh              # Current directory\n</code></pre> <p>Relative paths are like giving directions from where you are (\"go two blocks north, turn left\").</p> Path Type Starts With Example Works From Absolute <code>/</code> <code>/home/dan/file.txt</code> Anywhere Relative No <code>/</code> <code>Documents/file.txt</code> Current directory only Home-relative <code>~</code> <code>~/Documents/file.txt</code> Anywhere (expands to absolute)"},{"location":"chapters/04-file-system/#diagram-absolute-vs-relative-paths","title":"Diagram: Absolute vs Relative Paths","text":"Understanding Path Types <p>Type: diagram</p> <p>Bloom Taxonomy: Understand, Apply Learning Objective: Help students visualize the difference between absolute and relative paths with concrete examples.</p> <p>Components to show: - File system tree visualization - Current directory highlighted - Three example paths shown: absolute, relative, and home-relative - Arrows showing how each path type navigates the tree</p> <p>Layout: Tree diagram on left, path examples on right</p> <p>Example scenario: - Tree showing /home/dan/Documents/Projects/ - Current directory: /home/dan/Documents - Target: /home/dan/Documents/Projects/report.txt</p> <p>Paths compared: - Absolute: /home/dan/Documents/Projects/report.txt (starts at root, follows full path) - Relative: Projects/report.txt (starts at current dir) - Home-relative: ~/Documents/Projects/report.txt (starts at ~)</p> <p>Color coding: - Root (/): Red - Home directory: Green - Current directory: Blue highlight - Target file: Gold star</p> <p>Interactive features: - Click to change \"current directory\" - See how relative paths change but absolute stays same</p> <p>Implementation: p5.js or HTML/CSS</p>"},{"location":"chapters/04-file-system/#listing-files-the-ls-command","title":"Listing Files: The ls Command","text":"<p>The ls command is your window into directories. It lists the contents of a directory:</p> <pre><code>ls\n# Desktop  Documents  Downloads  Music  Pictures  Videos\n</code></pre> <p>By default, <code>ls</code> shows the current directory. You can specify any path:</p> <pre><code>ls /etc              # List /etc directory\nls ~/Documents       # List your Documents\nls ..                # List parent directory\n</code></pre>"},{"location":"chapters/04-file-system/#essential-ls-options","title":"Essential Ls Options","text":"<p>The <code>ls</code> command becomes much more powerful with ls options:</p> <pre><code># Long format (detailed info)\nls -l\n# -rw-r--r-- 1 dan dan 4096 Dec  6 14:30 file.txt\n\n# Show hidden files\nls -a\n# .  ..  .bashrc  .config  Documents  Downloads\n\n# Human-readable sizes\nls -h\n# (use with -l) Shows \"4.0K\" instead of \"4096\"\n\n# Combine options\nls -la         # Long format + hidden files\nls -lah        # Long + hidden + human-readable\n\n# Sort by time (newest first)\nls -lt\n\n# Sort by size (largest first)\nls -lS\n\n# Reverse sort order\nls -lr\n\n# Recursive (show subdirectories too)\nls -R\n</code></pre>"},{"location":"chapters/04-file-system/#understanding-ls-l-output","title":"Understanding ls -l Output","text":"<p>The long format (<code>ls -l</code>) shows lots of info:</p> <pre><code>-rw-r--r-- 1 dan dan 4096 Dec  6 14:30 report.txt\n\u2502\u251c\u2500\u2500\u252c\u2500\u2500\u2500\u2518  \u2502  \u2502   \u2502    \u2502      \u2502         \u2502\n\u2502\u2502  \u2502      \u2502  \u2502   \u2502    \u2502      \u2502         \u2514\u2500\u2500 Filename\n\u2502\u2502  \u2502      \u2502  \u2502   \u2502    \u2502      \u2514\u2500\u2500 Modification date/time\n\u2502\u2502  \u2502      \u2502  \u2502   \u2502    \u2514\u2500\u2500 File size (bytes)\n\u2502\u2502  \u2502      \u2502  \u2502   \u2514\u2500\u2500 Group owner\n\u2502\u2502  \u2502      \u2502  \u2514\u2500\u2500 User owner\n\u2502\u2502  \u2502      \u2514\u2500\u2500 Number of links\n\u2502\u2502  \u2514\u2500\u2500 Permissions (owner/group/others)\n\u2502\u2514\u2500\u2500 File type (- = file, d = directory, l = link)\n</code></pre> <p>Common file types in the first character:</p> Character Meaning <code>-</code> Regular file <code>d</code> Directory <code>l</code> Symbolic link <code>c</code> Character device <code>b</code> Block device"},{"location":"chapters/04-file-system/#hidden-files-and-dot-files","title":"Hidden Files and Dot Files","text":"<p>In Linux, any file or directory whose name starts with a dot (<code>.</code>) is hidden. These are called hidden files or dot files.</p> <pre><code>ls\n# Documents  Downloads  Music\n\nls -a\n# .  ..  .bashrc  .config  .hidden_file  Documents  Downloads  Music\n</code></pre> <p>Why hide files? Mostly to reduce clutter. Your home directory contains LOTS of configuration files that you don't need to see daily:</p> Dot File Purpose <code>.bashrc</code> Bash shell configuration <code>.bash_history</code> Your command history <code>.config/</code> Application configurations <code>.ssh/</code> SSH keys and settings <code>.gitconfig</code> Git configuration <code>.vimrc</code> Vim editor settings <p>Dot Files are Your Settings</p> <p>When you customize your shell, editor, or other programs, those settings are usually saved in dot files in your home directory. Learning to edit them gives you tremendous control over your environment!</p> <p>To show ONLY hidden files:</p> <pre><code>ls -d .*        # List only dot files/directories in current dir\n</code></pre>"},{"location":"chapters/04-file-system/#the-linux-directory-structure","title":"The Linux Directory Structure","text":"<p>Now let's explore the major directories in Linux. Understanding the directory structure helps you know where to find (and put) things.</p>"},{"location":"chapters/04-file-system/#bin-essential-binaries","title":"/bin - Essential Binaries","text":"<p>The bin directory (<code>/bin</code>) contains essential commands that must be available even if other parts of the system aren't mounted. These are commands needed to boot and repair the system:</p> <pre><code>ls /bin\n# bash  cat  cp  ls  mkdir  mv  rm  ...\n</code></pre> <p>Commands like <code>ls</code>, <code>cp</code>, <code>mv</code>, <code>cat</code>, <code>bash</code>\u2014the basics that you've been learning\u2014live here.</p> <p>Modern Systems: /bin \u2192 /usr/bin</p> <p>On modern Linux systems, <code>/bin</code> is often a symbolic link to <code>/usr/bin</code>. They've been merged for simplicity. You'll still see <code>/bin</code> referenced everywhere though!</p>"},{"location":"chapters/04-file-system/#etc-configuration-files","title":"/etc - Configuration Files","text":"<p>The etc directory (<code>/etc</code>) contains system-wide configuration files. The name supposedly came from \"et cetera\" (everything else), but it's now thought of as \"Editable Text Configuration.\"</p> <pre><code>ls /etc\n# apt/  bash.bashrc  hostname  hosts  passwd  ssh/  ...\n</code></pre> <p>Important files in /etc:</p> File Purpose <code>/etc/passwd</code> User account information <code>/etc/hosts</code> Local DNS mappings <code>/etc/hostname</code> System's hostname <code>/etc/apt/</code> APT package manager config <code>/etc/ssh/</code> SSH server configuration <p>Rule of thumb: If you need to configure something system-wide, look in <code>/etc</code>.</p>"},{"location":"chapters/04-file-system/#var-variable-data","title":"/var - Variable Data","text":"<p>The var directory (<code>/var</code>) contains files that change frequently during system operation:</p> <pre><code>ls /var\n# cache/  lib/  log/  mail/  spool/  tmp/  ...\n</code></pre> <p>Most importantly:</p> <ul> <li><code>/var/log/</code> - System log files (check here when debugging!)</li> <li><code>/var/cache/</code> - Application cache data</li> <li><code>/var/www/</code> - Web server files (on web servers)</li> </ul> <pre><code># View recent system logs\nls /var/log/\nsudo tail /var/log/syslog\n</code></pre>"},{"location":"chapters/04-file-system/#tmp-temporary-files","title":"/tmp - Temporary Files","text":"<p>The tmp directory (<code>/tmp</code>) is for temporary files. Key characteristics:</p> <ul> <li>Anyone can write here</li> <li>Files may be deleted on reboot</li> <li>Good for scratch space</li> </ul> <pre><code># Create a temp file\necho \"test\" &gt; /tmp/mytest.txt\n\n# It's there...\ncat /tmp/mytest.txt\n\n# But might be gone after reboot!\n</code></pre>"},{"location":"chapters/04-file-system/#usr-user-programs","title":"/usr - User Programs","text":"<p>The usr directory (<code>/usr</code>) contains user-installed programs, libraries, and documentation. Despite the name, \"usr\" doesn't mean \"user\"\u2014it historically meant \"Unix System Resources.\"</p> <pre><code>ls /usr\n# bin/  include/  lib/  local/  share/  ...\n</code></pre> <p>Key subdirectories:</p> <ul> <li><code>/usr/bin/</code> - Most user commands</li> <li><code>/usr/lib/</code> - Libraries</li> <li><code>/usr/share/</code> - Shared data (docs, icons, etc.)</li> <li><code>/usr/local/</code> - Locally compiled/installed software</li> </ul>"},{"location":"chapters/04-file-system/#opt-optional-software","title":"/opt - Optional Software","text":"<p>The opt directory (<code>/opt</code>) is for optional, third-party software packages. When you install something that doesn't come from your distribution's package manager, it often goes here:</p> <pre><code>ls /opt\n# google/  zoom/  discord/  ...\n</code></pre>"},{"location":"chapters/04-file-system/#dev-device-files","title":"/dev - Device Files","text":"<p>The dev directory (<code>/dev</code>) contains device files\u2014remember \"everything is a file\"? Here's where your hardware lives as files:</p> <pre><code>ls /dev\n# disk/  null  random  sda  tty  urandom  zero  ...\n</code></pre> <p>Interesting devices:</p> Device What It Is <code>/dev/null</code> The \"black hole\"\u2014discards anything written to it <code>/dev/zero</code> Produces infinite zeros <code>/dev/random</code> Random number generator <code>/dev/sda</code> First storage device <code>/dev/tty</code> Current terminal <pre><code># Send output to nowhere\necho \"This disappears\" &gt; /dev/null\n\n# Generate random data\nhead -c 10 /dev/random | xxd\n</code></pre>"},{"location":"chapters/04-file-system/#proc-process-information","title":"/proc - Process Information","text":"<p>The proc directory (<code>/proc</code>) is a virtual filesystem that provides information about running processes and the kernel:</p> <pre><code>ls /proc\n# 1/  2/  3/  cpuinfo  meminfo  version  ...\n</code></pre> <p>The numbered directories are process IDs. The files provide system info:</p> <pre><code># CPU information\ncat /proc/cpuinfo\n\n# Memory information\ncat /proc/meminfo\n\n# Kernel version\ncat /proc/version\n\n# Currently running processes (each number is a PID)\nls /proc | grep -E '^[0-9]+$' | head\n</code></pre> <p>/proc is Virtual</p> <p>The files in <code>/proc</code> don't actually exist on disk\u2014they're generated on-the-fly by the kernel when you read them. It's like a window into the system's soul!</p>"},{"location":"chapters/04-file-system/#diagram-linux-directory-structure","title":"Diagram: Linux Directory Structure","text":"Linux File System Hierarchy <p>Type: diagram</p> <p>Bloom Taxonomy: Remember, Understand Learning Objective: Provide a visual map of the Linux file system hierarchy that students can reference when navigating.</p> <p>Components to show: - Tree structure starting from / (root) - Major directories with icons representing their purpose - Brief description of each directory's role</p> <p>Layout: Hierarchical tree diagram</p> <p>Directories to show (with icons): - / (root) - House foundation icon   - /bin - Toolbox icon \"Essential commands\"   - /etc - Gear/settings icon \"System configuration\"   - /home - House icon \"User home directories\"     - /home/dan - Person icon     - /home/alice - Person icon   - /var - Stack of papers icon \"Variable/changing data\"     - /var/log - Scroll icon \"Log files\"   - /tmp - Trash/temp icon \"Temporary files\"   - /usr - Library icon \"User programs\"     - /usr/bin - Toolbox icon     - /usr/lib - Books icon     - /usr/local - Pin icon \"Locally installed\"   - /opt - Package icon \"Optional software\"   - /dev - USB/hardware icon \"Device files\"   - /proc - CPU icon \"Process info (virtual)\"</p> <p>Color coding: - System critical: Red - Configuration: Orange - User data: Green - Variable data: Blue - Virtual: Purple dashed</p> <p>Interactive features: - Hover for expanded description - Click to see example contents - Quiz mode: \"Where would you find log files?\"</p> <p>Implementation: p5.js or vis-network</p>"},{"location":"chapters/04-file-system/#quick-directory-reference","title":"Quick Directory Reference","text":"<p>Here's a cheat sheet for the major directories:</p> Directory Contents Remember It As <code>/</code> Root of everything \"The trunk of the tree\" <code>/bin</code> Essential commands \"Binary essentials\" <code>/etc</code> Configuration files \"Settings central\" <code>/home</code> User directories \"Your personal space\" <code>/var</code> Changing data, logs \"Variables and logs\" <code>/tmp</code> Temporary files \"Scratch paper\" <code>/usr</code> User programs \"Program library\" <code>/opt</code> Optional software \"Third-party apps\" <code>/dev</code> Device files \"Hardware as files\" <code>/proc</code> Process info \"System's pulse\""},{"location":"chapters/04-file-system/#the-tree-command-visualize-the-structure","title":"The Tree Command: Visualize the Structure","text":"<p>The tree command displays directories in a tree format\u2014much easier to read than multiple <code>ls</code> commands:</p> <pre><code>tree\n# .\n# \u251c\u2500\u2500 Documents\n# \u2502   \u251c\u2500\u2500 report.txt\n# \u2502   \u2514\u2500\u2500 notes.md\n# \u251c\u2500\u2500 Downloads\n# \u2502   \u2514\u2500\u2500 file.zip\n# \u2514\u2500\u2500 Pictures\n#     \u251c\u2500\u2500 photo1.jpg\n#     \u2514\u2500\u2500 photo2.jpg\n</code></pre> <p>Useful tree options:</p> <pre><code># Limit depth\ntree -L 2           # Only 2 levels deep\n\n# Show hidden files\ntree -a\n\n# Show only directories\ntree -d\n\n# Include file sizes\ntree -h             # Human-readable sizes\n\n# Show full path\ntree -f\n\n# Colorize output\ntree -C\n</code></pre> <p>Installing Tree</p> <p>Tree might not be installed by default. Install it with: <pre><code>sudo apt install tree     # Debian/Ubuntu\nbrew install tree         # macOS\n</code></pre></p>"},{"location":"chapters/04-file-system/#the-file-command-what-kind-of-file-is-this","title":"The File Command: What Kind of File Is This?","text":"<p>The file command tells you what type of file something is, regardless of its extension:</p> <pre><code>file report.txt\n# report.txt: ASCII text\n\nfile photo.jpg\n# photo.jpg: JPEG image data\n\nfile program\n# program: ELF 64-bit executable\n\nfile /bin/ls\n# /bin/ls: ELF 64-bit LSB pie executable, x86-64\n</code></pre> <p>This is super useful because: - Linux doesn't rely on file extensions - You can identify unknown files - You can verify files are what they claim to be</p> <pre><code># Someone sent you \"document.pdf\" but it won't open?\nfile document.pdf\n# document.pdf: ASCII text\n# It's actually a text file with wrong extension!\n</code></pre>"},{"location":"chapters/04-file-system/#the-stat-command-file-statistics","title":"The Stat Command: File Statistics","text":"<p>The stat command shows detailed statistics about a file:</p> <pre><code>stat report.txt\n</code></pre> <p>Output includes:</p> <ul> <li>File size</li> <li>Block size and count</li> <li>Device info</li> <li>Inode number</li> <li>Access, modification, and change times</li> <li>Permissions in multiple formats</li> </ul> <pre><code>  File: report.txt\n  Size: 4096        Blocks: 8          IO Block: 4096   regular file\nDevice: 801h/2049d  Inode: 1234567     Links: 1\nAccess: (0644/-rw-r--r--)  Uid: ( 1000/dan)   Gid: ( 1000/dan)\nAccess: 2025-12-06 14:30:00.000000000 -0800\nModify: 2025-12-06 14:25:00.000000000 -0800\nChange: 2025-12-06 14:25:00.000000000 -0800\n Birth: 2025-12-06 10:00:00.000000000 -0800\n</code></pre> <p>Three important timestamps:</p> Time Meaning Updated When Access (atime) Last read File was read Modify (mtime) Last content change File contents changed Change (ctime) Last metadata change Permissions, owner, etc. changed"},{"location":"chapters/04-file-system/#pathnames-putting-it-all-together","title":"Pathnames: Putting It All Together","text":"<p>Pathnames are the full address of a file in the file system. Everything we've learned comes together here:</p> <pre><code># Absolute pathnames\n/home/dan/Documents/report.txt\n/etc/ssh/sshd_config\n/var/log/syslog\n\n# Relative pathnames (depends on current directory)\nDocuments/report.txt\n../alice/photos/vacation.jpg\n./script.sh\n\n# Home-relative pathnames\n~/Documents/report.txt\n~alice/photos/vacation.jpg\n</code></pre> <p>Tips for working with pathnames:</p> <ul> <li>Use Tab completion! (Press Tab to auto-complete paths)</li> <li>Use quotes for paths with spaces: <code>\"My Documents/file.txt\"</code></li> <li>Use wildcards: <code>ls *.txt</code> matches all .txt files</li> <li>Escape spaces with backslash: <code>My\\ Documents/file.txt</code></li> </ul>"},{"location":"chapters/04-file-system/#opening-files-the-open-command","title":"Opening Files: The open Command","text":"<p>Want to open a file with its default application from the command line?</p>"},{"location":"chapters/04-file-system/#macos-the-open-command","title":"macOS: The open Command","text":"<p>On macOS, the macOS open command opens files with their default application:</p> <pre><code>open report.pdf       # Opens in Preview\nopen photo.jpg        # Opens in Photos\nopen .                # Opens current directory in Finder\nopen -a Safari url    # Open with specific app\n</code></pre>"},{"location":"chapters/04-file-system/#linux-xdg-open-and-aliases","title":"Linux: xdg-open and Aliases","text":"<p>On Linux, use <code>xdg-open</code>:</p> <pre><code>xdg-open report.pdf   # Opens with default PDF viewer\nxdg-open photo.jpg    # Opens with default image viewer\nxdg-open .            # Opens file manager\n</code></pre> <p>Since <code>xdg-open</code> is harder to type, many people create an open alias on Linux:</p> <pre><code># Add to your ~/.bashrc\nalias open='xdg-open'\n\n# Now you can use:\nopen file.pdf\n</code></pre> <p>Other options depending on your desktop environment:</p> <pre><code># GNOME\ngio open file.pdf\n\n# KDE\nkde-open file.pdf\n\n# Generic (with alias)\nalias open='xdg-open 2&gt;/dev/null'\n</code></pre>"},{"location":"chapters/04-file-system/#practical-navigation-exercises","title":"Practical Navigation Exercises","text":"<p>Let's practice! Try these in your terminal:</p>"},{"location":"chapters/04-file-system/#exercise-1-where-am-i","title":"Exercise 1: Where Am I?","text":"<pre><code># Print your current directory\npwd\n\n# Go home\ncd\n\n# Verify you're home\npwd\n\n# What's in your home directory?\nls -la\n</code></pre>"},{"location":"chapters/04-file-system/#exercise-2-explore-the-system","title":"Exercise 2: Explore the System","text":"<pre><code># Go to root\ncd /\n\n# List top-level directories\nls\n\n# Explore /etc\ncd /etc\nls | head -20\n\n# Look at a config file\ncat hostname\n\n# Go back home\ncd ~\n</code></pre>"},{"location":"chapters/04-file-system/#exercise-3-path-practice","title":"Exercise 3: Path Practice","text":"<pre><code># Create a test structure\nmkdir -p ~/test/level1/level2/level3\ncd ~/test/level1/level2/level3\n\n# Where are you? (absolute path)\npwd\n\n# Go up two levels\ncd ../..\npwd\n\n# Go back down using relative path\ncd level2/level3\npwd\n\n# Go home with ~\ncd ~\n\n# Clean up\nrm -r ~/test\n</code></pre>"},{"location":"chapters/04-file-system/#exercise-4-hidden-files-hunt","title":"Exercise 4: Hidden Files Hunt","text":"<pre><code># Go home\ncd ~\n\n# List visible files\nls\n\n# List ALL files (including hidden)\nls -la\n\n# Count your dot files\nls -a | grep '^\\.' | wc -l\n\n# Look at your .bashrc\ncat ~/.bashrc | head -20\n</code></pre>"},{"location":"chapters/04-file-system/#diagram-file-system-navigation-microsim","title":"Diagram: File System Navigation MicroSim","text":"Interactive File System Navigator <p>Type: microsim</p> <p>Bloom Taxonomy: Apply, Analyze Learning Objective: Let students practice navigating the file system with cd, ls, and pwd in a safe simulated environment.</p> <p>Canvas layout (responsive, ~750px max width): - Top area (100px): Current path display (like a breadcrumb) - Middle area (350px): Visual file system tree - Bottom area (150px): Terminal input and output</p> <p>Visual elements: - Tree visualization of a simulated file system - Current directory highlighted - Clickable directories in the tree - Terminal-style command input - Output display</p> <p>Simulated file system: - /   - home/     - student/       - Documents/         - report.txt         - notes.md       - Downloads/         - image.png       - .bashrc (hidden)       - .config/ (hidden)   - etc/     - hosts     - hostname   - var/     - log/   - tmp/</p> <p>Interactive elements: - Type commands: cd, ls, pwd, ls -a, ls -l - Click directories in tree to navigate (auto-generates cd command) - \"pwd\" updates the breadcrumb display - Tab completion simulation</p> <p>Challenges (optional): 1. \"Navigate to your Documents folder\" 2. \"List hidden files in your home directory\" 3. \"Go to /var/log and back home in one command\" 4. \"What's the absolute path of report.txt?\"</p> <p>Behavior: - Commands execute and update visualization - Invalid commands show helpful errors - Tree view highlights current location - Success animations for completed challenges</p> <p>Implementation: p5.js</p>"},{"location":"chapters/04-file-system/#key-takeaways","title":"Key Takeaways","text":"<p>You've learned how to navigate the Linux file system like a pro! Here's what to remember:</p> <ul> <li>Everything is a file in Linux\u2014even devices and processes</li> <li>The root directory (<code>/</code>) is the top of the file system tree</li> <li>Your home directory (<code>~</code>) is your personal space</li> <li>Use pwd to see where you are, cd to move around</li> <li>Absolute paths start with <code>/</code>, relative paths don't</li> <li>Hidden files start with a dot (<code>.</code>)</li> <li>Use ls -la to see everything including hidden files</li> <li>Key directories: <code>/bin</code> (commands), <code>/etc</code> (config), <code>/home</code> (users), <code>/var</code> (logs)</li> <li>tree shows directory structure visually</li> <li>file tells you what type of file something is</li> <li>stat shows detailed file information</li> </ul> <p>You Can Navigate!</p> <p>You now have a mental map of the Linux file system. You know where system files live, where your files go, and how to get anywhere using paths. This knowledge will serve you in every future chapter!</p>"},{"location":"chapters/04-file-system/#whats-next","title":"What's Next?","text":"<p>Now that you can navigate the file system, it's time to learn how to actually DO things with files! In the next chapter, you'll master:</p> <ul> <li>Creating files and directories</li> <li>Copying, moving, and renaming files</li> <li>Deleting files (carefully!)</li> <li>Working with file content</li> </ul> <p>Time to stop just looking at files and start manipulating them!</p> Quick Quiz: File System Fundamentals <ol> <li>What character represents the root directory?</li> <li>What command shows your current directory?</li> <li>How do you go to your home directory from anywhere?</li> <li>What's the difference between <code>/etc</code> and <code>/tmp</code>?</li> <li>How do you list hidden files?</li> </ol> Quiz Answers <ol> <li><code>/</code> (forward slash)</li> <li><code>pwd</code> (print working directory)</li> <li><code>cd ~</code> or just <code>cd</code> with no arguments</li> <li><code>/etc</code> contains configuration files; <code>/tmp</code> contains temporary files that may be deleted on reboot</li> <li><code>ls -a</code> (the -a flag shows all files including hidden)</li> </ol>"},{"location":"chapters/05-file-operations/","title":"File Operations and Manipulation","text":""},{"location":"chapters/05-file-operations/#summary","title":"Summary","text":"<p>This chapter teaches you how to create, copy, move, and delete files and directories. You'll learn essential commands like touch, mkdir, cp, mv, and rm, as well as how to view file contents using cat, head, tail, and less. These are the everyday operations you'll perform constantly when working with Linux.</p>"},{"location":"chapters/05-file-operations/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 20 concepts from the learning graph:</p> <ol> <li>Touch Command</li> <li>Mkdir Command</li> <li>Rmdir Command</li> <li>Cp Command</li> <li>Mv Command</li> <li>Rm Command</li> <li>Rm Recursive</li> <li>Cat Command</li> <li>Head Command</li> <li>Tail Command</li> <li>Less Command</li> <li>More Command</li> <li>Wc Command</li> <li>Sort Command</li> <li>Uniq Command</li> <li>Cut Command</li> <li>Paste Command</li> <li>Diff Command</li> </ol>"},{"location":"chapters/05-file-operations/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 4: File System Fundamentals</li> </ul> <p>TODO: Generate Chapter Content</p>"},{"location":"chapters/06-advanced-files/","title":"Advanced File Operations","text":""},{"location":"chapters/06-advanced-files/#summary","title":"Summary","text":"<p>This chapter covers advanced file manipulation techniques including symbolic and hard links, wildcards and file globbing patterns, and file attributes. You'll learn how to work with multiple files efficiently using pattern matching, understand the difference between symbolic and hard links, and explore file metadata like timestamps and attributes.</p>"},{"location":"chapters/06-advanced-files/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 20 concepts from the learning graph:</p> <ol> <li>Symbolic Links</li> <li>Hard Links</li> <li>Ln Command</li> <li>File Globbing</li> <li>Wildcards</li> <li>Asterisk Wildcard</li> <li>Question Mark Wildcard</li> <li>Bracket Expressions</li> <li>Brace Expansion</li> <li>Tilde Expansion</li> <li>File Attributes</li> <li>File Timestamps</li> </ol>"},{"location":"chapters/06-advanced-files/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 4: File System Fundamentals</li> <li>Chapter 5: File Operations and Manipulation</li> </ul> <p>TODO: Generate Chapter Content</p>"},{"location":"chapters/07-permissions/","title":"File Permissions and Ownership","text":""},{"location":"chapters/07-permissions/#summary","title":"Summary","text":"<p>This chapter provides comprehensive coverage of Linux's permission system, one of the key security features of the operating system. You'll learn about read, write, and execute permissions for owners, groups, and others, master chmod and chown commands, understand user accounts and the root user, and learn to use sudo safely. Special permission bits like setuid, setgid, and sticky bit are also covered.</p>"},{"location":"chapters/07-permissions/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 25 concepts from the learning graph:</p> <ol> <li>File Permissions</li> <li>Read Permission</li> <li>Write Permission</li> <li>Execute Permission</li> <li>Owner Permissions</li> <li>Group Permissions</li> <li>Other Permissions</li> <li>Permission Notation</li> <li>Numeric Permissions</li> <li>Chmod Command</li> <li>Chown Command</li> <li>Chgrp Command</li> <li>User Accounts</li> <li>Root User</li> <li>Sudo Command</li> <li>Su Command</li> <li>User Groups</li> <li>Primary Group</li> <li>Secondary Groups</li> <li>Umask Command</li> <li>Default Permissions</li> <li>Setuid Bit</li> <li>Setgid Bit</li> <li>Sticky Bit</li> <li>Special Permissions</li> </ol>"},{"location":"chapters/07-permissions/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 4: File System Fundamentals</li> <li>Chapter 5: File Operations and Manipulation</li> </ul> <p>TODO: Generate Chapter Content</p>"},{"location":"chapters/08-grep-regex/","title":"Text Processing with Grep and Regular Expressions","text":""},{"location":"chapters/08-grep-regex/#summary","title":"Summary","text":"<p>This chapter introduces powerful text search techniques using grep and regular expressions. You'll learn to search for patterns in files, understand basic and extended regular expressions, and master metacharacters, anchors, character classes, and quantifiers. Regular expressions are a fundamental skill used across programming languages and tools.</p>"},{"location":"chapters/08-grep-regex/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 15 concepts from the learning graph:</p> <ol> <li>Grep Command</li> <li>Grep Options</li> <li>Regular Expressions</li> <li>Basic Regex</li> <li>Extended Regex</li> <li>Regex Metacharacters</li> <li>Regex Anchors</li> <li>Regex Character Classes</li> <li>Regex Quantifiers</li> </ol>"},{"location":"chapters/08-grep-regex/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 5: File Operations and Manipulation</li> </ul> <p>TODO: Generate Chapter Content</p>"},{"location":"chapters/09-sed-awk-pipes/","title":"Advanced Text Processing: Sed, Awk, and Pipes","text":""},{"location":"chapters/09-sed-awk-pipes/#summary","title":"Summary","text":"<p>This chapter covers advanced text processing with sed for stream editing and awk for field-based processing. You'll also master the UNIX philosophy in action: connecting commands with pipes, understanding text streams (stdin, stdout, stderr), and using redirection operators. These skills enable you to build powerful data processing pipelines.</p>"},{"location":"chapters/09-sed-awk-pipes/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 15 concepts from the learning graph:</p> <ol> <li>Sed Command</li> <li>Sed Substitution</li> <li>Awk Command</li> <li>Awk Fields</li> <li>Awk Patterns</li> <li>Text Streams</li> <li>Standard Input</li> <li>Standard Output</li> <li>Standard Error</li> <li>Redirection</li> <li>Output Redirection</li> <li>Input Redirection</li> <li>Append Redirection</li> <li>Error Redirection</li> <li>Pipe Operator</li> <li>Pipeline Commands</li> <li>Xargs Command</li> <li>Tee Command</li> <li>Tr Command</li> <li>Rev Command</li> <li>Fold Command</li> </ol>"},{"location":"chapters/09-sed-awk-pipes/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 5: File Operations and Manipulation</li> <li>Chapter 8: Text Processing with Grep and Regular Expressions</li> </ul> <p>TODO: Generate Chapter Content</p>"},{"location":"chapters/10-text-editors/","title":"Text Editors: Nano and Vim","text":""},{"location":"chapters/10-text-editors/#summary","title":"Summary","text":"<p>This chapter teaches you to edit files directly in the terminal using two popular editors. Nano provides a beginner-friendly interface with on-screen shortcuts, while Vim offers powerful modal editing for advanced users. You'll learn Vim's modes (insert, command, visual), navigation, search and replace, and configuration through vimrc.</p>"},{"location":"chapters/10-text-editors/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 15 concepts from the learning graph:</p> <ol> <li>Text Editors</li> <li>Nano Editor</li> <li>Nano Commands</li> <li>Nano Shortcuts</li> <li>Vi Editor</li> <li>Vim Editor</li> <li>Vim Modes</li> <li>Vim Insert Mode</li> <li>Vim Command Mode</li> <li>Vim Visual Mode</li> <li>Vim Navigation</li> <li>Vim Save and Quit</li> <li>Vim Search Replace</li> <li>Vimrc Configuration</li> <li>Editor Selection</li> </ol>"},{"location":"chapters/10-text-editors/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 4: File System Fundamentals</li> <li>Chapter 5: File Operations and Manipulation</li> </ul> <p>TODO: Generate Chapter Content</p>"},{"location":"chapters/11-shell-config/","title":"Shell Configuration and Environment","text":""},{"location":"chapters/11-shell-config/#summary","title":"Summary","text":"<p>This chapter teaches you to customize your shell environment for productivity. You'll learn about dotfiles (.bashrc, .zshrc), environment variables like PATH and HOME, creating aliases and shell functions, and understanding how shells load configuration files at startup. A well-configured shell can dramatically improve your daily workflow.</p>"},{"location":"chapters/11-shell-config/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 20 concepts from the learning graph:</p> <ol> <li>Shell Configuration</li> <li>Bashrc File</li> <li>Bash Profile</li> <li>Zshrc File</li> <li>Profile File</li> <li>Environment Variables</li> <li>PATH Variable</li> <li>HOME Variable</li> <li>USER Variable</li> <li>SHELL Variable</li> <li>Export Command</li> <li>Source Command</li> <li>Alias Command</li> <li>Creating Aliases</li> <li>Removing Aliases</li> <li>Shell Functions</li> <li>Shell Startup Order</li> </ol>"},{"location":"chapters/11-shell-config/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 2: Getting Started with the Terminal</li> <li>Chapter 4: File System Fundamentals</li> <li>Chapter 10: Text Editors: Nano and Vim</li> </ul> <p>TODO: Generate Chapter Content</p>"},{"location":"chapters/12-processes/","title":"Process Management and Job Control","text":""},{"location":"chapters/12-processes/#summary","title":"Summary","text":"<p>This chapter explains how Linux manages running programs. You'll learn about processes, process IDs, and the parent-child relationship between processes. Master job control with foreground/background processes, monitor system activity with ps, top, and htop, and learn to terminate processes with kill signals. Understanding processes is essential for troubleshooting and system administration.</p>"},{"location":"chapters/12-processes/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 25 concepts from the learning graph:</p> <ol> <li>Processes</li> <li>Process ID</li> <li>Parent Process</li> <li>Child Process</li> <li>Foreground Process</li> <li>Background Process</li> <li>Ps Command</li> <li>Ps Options</li> <li>Top Command</li> <li>Htop Command</li> <li>Kill Command</li> <li>Kill Signals</li> <li>Killall Command</li> <li>Pkill Command</li> <li>Jobs Command</li> <li>Fg Command</li> <li>Bg Command</li> <li>Nohup Command</li> <li>Ampersand Operator</li> <li>Process Priority</li> <li>Nice Command</li> <li>Renice Command</li> <li>Pgrep Command</li> <li>Process States</li> <li>Zombie Processes</li> </ol>"},{"location":"chapters/12-processes/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 2: Getting Started with the Terminal</li> <li>Chapter 3: Basic Shell Commands and Help Systems</li> </ul> <p>TODO: Generate Chapter Content</p>"},{"location":"chapters/13-scripting/","title":"Shell Scripting and Automation","text":""},{"location":"chapters/13-scripting/#summary","title":"Summary","text":"<p>This chapter introduces shell scripting to automate repetitive tasks. You'll learn to write scripts with proper shebang lines, use variables and command-line arguments, handle exit codes, and schedule automated tasks with cron. Shell scripting is a foundational skill for system administration and DevOps.</p>"},{"location":"chapters/13-scripting/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 15 concepts from the learning graph:</p> <ol> <li>Shell Scripts</li> <li>Script Shebang</li> <li>Script Permissions</li> <li>Script Variables</li> <li>Script Arguments</li> <li>Script Exit Codes</li> <li>Cron Daemon</li> <li>Crontab Command</li> <li>Cron Syntax</li> <li>Cron Schedule Fields</li> <li>Cron Examples</li> <li>At Command</li> <li>Batch Command</li> <li>Systemd Timers</li> <li>Anacron</li> </ol>"},{"location":"chapters/13-scripting/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 7: File Permissions and Ownership</li> <li>Chapter 11: Shell Configuration and Environment</li> <li>Chapter 12: Process Management and Job Control</li> </ul> <p>TODO: Generate Chapter Content</p>"},{"location":"chapters/14-package-mgmt/","title":"Package Management","text":""},{"location":"chapters/14-package-mgmt/#summary","title":"Summary","text":"<p>This chapter teaches you to install, update, and manage software on Linux. You'll master APT for Debian/Ubuntu systems, learn about dpkg, Snap, and Flatpak package formats, and explore Homebrew for cross-platform package management. Understanding package managers and repositories is essential for maintaining a healthy Linux system.</p>"},{"location":"chapters/14-package-mgmt/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 20 concepts from the learning graph:</p> <ol> <li>Package Manager</li> <li>Software Packages</li> <li>Package Repositories</li> <li>APT Package Manager</li> <li>Apt Update</li> <li>Apt Upgrade</li> <li>Apt Install</li> <li>Apt Remove</li> <li>Apt Search</li> <li>Apt Show</li> <li>Dpkg Command</li> <li>Snap Packages</li> <li>Flatpak</li> <li>Homebrew</li> <li>Brew Install</li> <li>Brew Update</li> <li>Package Dependencies</li> <li>Repository Sources</li> <li>PPA Repositories</li> <li>Software Updates</li> </ol>"},{"location":"chapters/14-package-mgmt/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 1: Introduction to Operating Systems and UNIX History</li> <li>Chapter 7: File Permissions and Ownership</li> </ul> <p>TODO: Generate Chapter Content</p>"},{"location":"chapters/15-networking/","title":"Networking Fundamentals","text":""},{"location":"chapters/15-networking/#summary","title":"Summary","text":"<p>This chapter introduces essential networking concepts and commands. You'll learn about IP addresses, DNS, and network interfaces, then master diagnostic tools like ping, traceroute, netstat, and ss. You'll also learn to transfer files with curl and wget. These networking fundamentals are crucial for troubleshooting connectivity issues and working with remote systems.</p>"},{"location":"chapters/15-networking/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 25 concepts from the learning graph:</p> <ol> <li>Network Basics</li> <li>IP Address</li> <li>MAC Address</li> <li>DNS</li> <li>Hostname Resolution</li> <li>Network Interfaces</li> <li>Ifconfig Command</li> <li>Ip Command</li> <li>Ping Command</li> <li>Traceroute Command</li> <li>Netstat Command</li> <li>Ss Command</li> <li>Curl Command</li> <li>Wget Command</li> <li>Network Ports</li> <li>WiFi Configuration</li> <li>Network Troubleshooting</li> </ol>"},{"location":"chapters/15-networking/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 2: Getting Started with the Terminal</li> <li>Chapter 3: Basic Shell Commands and Help Systems</li> </ul> <p>TODO: Generate Chapter Content</p>"},{"location":"chapters/16-ssh-security/","title":"SSH and Remote Access","text":""},{"location":"chapters/16-ssh-security/#summary","title":"Summary","text":"<p>This chapter covers secure remote access to Linux systems using SSH. You'll learn about the SSH protocol, key-based authentication (far more secure than passwords), configuring SSH clients, and transferring files with SCP and rsync. You'll also learn firewall basics with UFW and understand network security principles.</p>"},{"location":"chapters/16-ssh-security/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 15 concepts from the learning graph:</p> <ol> <li>SSH Protocol</li> <li>SSH Command</li> <li>SSH Keys</li> <li>SSH Config</li> <li>SCP Command</li> <li>Rsync Command</li> <li>Firewall Basics</li> <li>UFW Firewall</li> <li>Firewall Rules</li> <li>Linux Security</li> <li>User Authentication</li> <li>Password Security</li> <li>SSH Security</li> <li>Key-Based Auth</li> <li>Port Security</li> <li>Secure File Transfer</li> <li>Security Updates</li> <li>Vulnerability Scanning</li> <li>Log Files</li> <li>Audit Logs</li> <li>Security Best Practices</li> </ol>"},{"location":"chapters/16-ssh-security/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 7: File Permissions and Ownership</li> <li>Chapter 15: Networking Fundamentals</li> </ul> <p>TODO: Generate Chapter Content</p>"},{"location":"chapters/17-compression-search/","title":"Compression, Archives, and File Search","text":""},{"location":"chapters/17-compression-search/#summary","title":"Summary","text":"<p>This chapter teaches you to compress files, create archives, and search for files efficiently. You'll master gzip, bzip2, tar, and zip commands, understand different compression algorithms and their trade-offs, and learn powerful file search techniques with find, locate, which, and whereis. These skills are essential for managing disk space and finding files quickly.</p>"},{"location":"chapters/17-compression-search/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 30 concepts from the learning graph:</p> <ol> <li>File Compression</li> <li>Gzip Command</li> <li>Gunzip Command</li> <li>Bzip2 Command</li> <li>Xz Command</li> <li>Tar Command</li> <li>Tar Create</li> <li>Tar Extract</li> <li>Tar Options</li> <li>Zip Command</li> <li>Unzip Command</li> <li>Archive Formats</li> <li>Compression Ratios</li> <li>7zip Command</li> <li>File Archiving</li> <li>Find Command</li> <li>Find by Name</li> <li>Find by Type</li> <li>Find by Size</li> <li>Find by Time</li> <li>Find with Exec</li> <li>Locate Command</li> <li>Updatedb Command</li> <li>Which Command</li> <li>Whereis Command</li> <li>Type Command</li> <li>File Search Patterns</li> <li>Recursive Search</li> <li>Search Optimization</li> <li>Index Databases</li> </ol>"},{"location":"chapters/17-compression-search/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 4: File System Fundamentals</li> <li>Chapter 5: File Operations and Manipulation</li> <li>Chapter 6: Advanced File Operations</li> </ul> <p>TODO: Generate Chapter Content</p>"},{"location":"chapters/18-storage-perf/","title":"Storage Devices and System Performance","text":""},{"location":"chapters/18-storage-perf/#summary","title":"Summary","text":"<p>This chapter covers storage management and performance monitoring. You'll learn about block and character devices, mounting file systems, disk partitions, and swap space. Master performance monitoring tools like df, du, free, vmstat, and iostat to understand system resource usage and identify bottlenecks. These skills are essential for system administration.</p>"},{"location":"chapters/18-storage-perf/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 35 concepts from the learning graph:</p> <ol> <li>Storage Devices</li> <li>Block Devices</li> <li>Character Devices</li> <li>Device Files</li> <li>Mount Command</li> <li>Umount Command</li> <li>Fstab File</li> <li>Disk Partitions</li> <li>Fdisk Command</li> <li>Lsblk Command</li> <li>Df Command</li> <li>Du Command</li> <li>USB Drives</li> <li>Flash Drives</li> <li>Swap Space</li> <li>Swap File</li> <li>Swap Partition</li> <li>File System Types</li> <li>Ext4 File System</li> <li>NTFS Support</li> <li>System Monitoring</li> <li>CPU Usage</li> <li>Memory Usage</li> <li>Disk Usage</li> <li>Free Command</li> <li>Vmstat Command</li> <li>Iostat Command</li> <li>Sar Command</li> <li>Performance Tuning</li> <li>CPU Benchmarks</li> <li>Disk Benchmarks</li> <li>GPU Performance</li> <li>System Load</li> <li>Load Average</li> <li>Bottleneck Analysis</li> </ol>"},{"location":"chapters/18-storage-perf/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 4: File System Fundamentals</li> <li>Chapter 12: Process Management and Job Control</li> </ul> <p>TODO: Generate Chapter Content</p>"},{"location":"chapters/19-raspberry-pi/","title":"Introduction to Raspberry Pi","text":""},{"location":"chapters/19-raspberry-pi/#summary","title":"Summary","text":"<p>This chapter introduces the Raspberry Pi, an affordable single-board computer perfect for learning Linux. You'll learn about different Pi models (Zero, 4, 5, and the new 500), how to set up Raspberry Pi OS, and understand the hardware interfaces including GPIO headers, USB, HDMI, and networking ports. The Raspberry Pi makes Linux tangible and opens doors to hardware projects.</p>"},{"location":"chapters/19-raspberry-pi/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 25 concepts from the learning graph:</p> <ol> <li>Raspberry Pi</li> <li>Raspberry Pi Models</li> <li>Raspberry Pi Zero</li> <li>Raspberry Pi 4</li> <li>Raspberry Pi 5</li> <li>Raspberry Pi 500</li> <li>Raspberry Pi OS</li> <li>Pi Imager</li> <li>SD Card Setup</li> <li>Pi First Boot</li> <li>Raspi-Config</li> <li>Pi Desktop</li> <li>Pi Terminal</li> <li>Pi GPIO Header</li> <li>GPIO Pins</li> <li>GPIO Voltage</li> <li>GPIO Ground Pins</li> <li>GPIO Power Pins</li> <li>GPIO Data Pins</li> <li>Pi Camera Module</li> <li>Pi USB Ports</li> <li>Pi HDMI Ports</li> <li>Pi Ethernet Port</li> <li>Pi WiFi</li> <li>Pi Bluetooth</li> </ol>"},{"location":"chapters/19-raspberry-pi/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 1: Introduction to Operating Systems and UNIX History</li> <li>Chapter 2: Getting Started with the Terminal</li> <li>Chapter 15: Networking Fundamentals</li> </ul> <p>TODO: Generate Chapter Content</p>"},{"location":"chapters/20-gpio-iot/","title":"GPIO Programming and Hardware Projects","text":""},{"location":"chapters/20-gpio-iot/#summary","title":"Summary","text":"<p>This chapter dives deep into hardware interfacing with the Raspberry Pi GPIO pins. You'll learn to control LEDs and NeoPixel strips, read sensors (temperature, motion, light), control motors (DC, servo, stepper), and build IoT projects. The chapter culminates in home automation concepts including Home Assistant, Node-RED, and remote monitoring dashboards.</p>"},{"location":"chapters/20-gpio-iot/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 40 concepts from the learning graph:</p> <ol> <li>GPIO Programming</li> <li>GPIO Input</li> <li>GPIO Output</li> <li>Digital Signals</li> <li>PWM Signals</li> <li>LED Control</li> <li>LED Strip</li> <li>NeoPixel LEDs</li> <li>Button Input</li> <li>Sensor Reading</li> <li>Temperature Sensor</li> <li>Motion Sensor</li> <li>Light Sensor</li> <li>Motor Control</li> <li>DC Motors</li> <li>Servo Motors</li> <li>Stepper Motors</li> <li>Motor Drivers</li> <li>External Power</li> <li>Current Monitoring</li> <li>Internet of Things</li> <li>IoT Sensors</li> <li>IoT Protocols</li> <li>MQTT Protocol</li> <li>Home Automation</li> <li>Smart Home Hub</li> <li>Home Monitoring</li> <li>Temperature Logging</li> <li>Security Cameras</li> <li>Motion Detection</li> <li>Remote Access</li> <li>Web Dashboard</li> <li>Data Logging</li> <li>Time Series Data</li> <li>Alerts and Notifications</li> <li>Home Assistant</li> <li>Node-RED</li> <li>IFTTT Integration</li> <li>Voice Control</li> <li>Automation Scripts</li> </ol>"},{"location":"chapters/20-gpio-iot/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 13: Shell Scripting and Automation</li> <li>Chapter 16: SSH and Remote Access</li> <li>Chapter 19: Introduction to Raspberry Pi</li> </ul> <p>TODO: Generate Chapter Content</p>"},{"location":"chapters/21-cloud-containers/","title":"Cloud Computing and Containers","text":""},{"location":"chapters/21-cloud-containers/#summary","title":"Summary","text":"<p>This chapter introduces modern cloud computing and containerization. You'll learn about cloud providers, virtual machines, and how to launch Linux instances in the cloud. Master Docker containers from building images to running multi-container applications with Docker Compose. Explore Terraform for infrastructure-as-code to automate cloud deployments.</p>"},{"location":"chapters/21-cloud-containers/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 25 concepts from the learning graph:</p> <ol> <li>Cloud Computing</li> <li>Virtual Machines</li> <li>Cloud Providers</li> <li>AWS Basics</li> <li>Cloud Linux Instances</li> <li>SSH to Cloud</li> <li>Docker</li> <li>Docker Images</li> <li>Docker Containers</li> <li>Docker Commands</li> <li>Docker Run</li> <li>Docker Build</li> <li>Dockerfile</li> <li>Docker Compose</li> <li>Container Networking</li> <li>Container Volumes</li> <li>Terraform Basics</li> <li>Infrastructure as Code</li> <li>Terraform Providers</li> <li>Terraform Resources</li> <li>Cloud Deployment</li> <li>Container Registry</li> <li>Microservices</li> <li>Cloud Security</li> <li>Cost Management</li> </ol>"},{"location":"chapters/21-cloud-containers/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 15: Networking Fundamentals</li> <li>Chapter 16: SSH and Remote Access</li> <li>Chapter 18: Storage Devices and System Performance</li> </ul> <p>TODO: Generate Chapter Content</p>"},{"location":"chapters/22-dev-tools/","title":"Development Tools and Version Control","text":""},{"location":"chapters/22-dev-tools/#summary","title":"Summary","text":"<p>This chapter covers essential development tools for Linux. Master Git version control from basic commits to branching and merging, learn to collaborate on GitHub, and set up Python development environments with virtual environments and package managers. Explore IDEs like VSCode and Thonny, and learn debugging techniques.</p>"},{"location":"chapters/22-dev-tools/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 25 concepts from the learning graph:</p> <ol> <li>Version Control</li> <li>Git Basics</li> <li>Git Init</li> <li>Git Clone</li> <li>Git Add</li> <li>Git Commit</li> <li>Git Push</li> <li>Git Pull</li> <li>Git Branch</li> <li>Git Merge</li> <li>GitHub</li> <li>GitHub Repositories</li> <li>GitHub SSH Keys</li> <li>Python on Linux</li> <li>Python3 Command</li> <li>Pip Package Manager</li> <li>Virtual Environments</li> <li>Venv Module</li> <li>Conda Environment</li> <li>VSCode on Linux</li> <li>Thonny IDE</li> <li>Code Editors</li> <li>Debugging Tools</li> <li>GDB Debugger</li> <li>Print Debugging</li> </ol>"},{"location":"chapters/22-dev-tools/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 1: Introduction to Operating Systems and UNIX History</li> <li>Chapter 10: Text Editors: Nano and Vim</li> <li>Chapter 16: SSH and Remote Access</li> </ul> <p>TODO: Generate Chapter Content</p>"},{"location":"chapters/23-sys-admin/","title":"System Administration Essentials","text":""},{"location":"chapters/23-sys-admin/#summary","title":"Summary","text":"<p>This chapter covers essential system administration tasks. You'll learn user and group management, controlling system services with systemd, understanding the boot process, and configuring displays and audio. These skills prepare you for managing Linux systems in both personal and professional environments.</p>"},{"location":"chapters/23-sys-admin/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 25 concepts from the learning graph:</p> <ol> <li>System Administration</li> <li>User Management</li> <li>Useradd Command</li> <li>Usermod Command</li> <li>Userdel Command</li> <li>Group Management</li> <li>Password Management</li> <li>Passwd Command</li> <li>Shutdown Command</li> <li>Reboot Command</li> <li>System Services</li> <li>Systemctl Command</li> <li>Service Status</li> <li>Service Start Stop</li> <li>Boot Process</li> <li>Display Configuration</li> <li>HDMI Output</li> <li>Multiple Displays</li> <li>Display Resolution</li> <li>Screen Command</li> <li>Tmux Multiplexer</li> <li>Audio Configuration</li> <li>ALSA Audio</li> <li>PulseAudio</li> <li>Volume Control</li> <li>Audio Output</li> <li>Bluetooth Audio</li> <li>USB Audio</li> <li>Sound Testing</li> <li>Audio Troubleshooting</li> <li>File Encryption</li> <li>GPG Encryption</li> </ol>"},{"location":"chapters/23-sys-admin/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 7: File Permissions and Ownership</li> <li>Chapter 12: Process Management and Job Control</li> <li>Chapter 14: Package Management</li> </ul> <p>TODO: Generate Chapter Content</p>"},{"location":"chapters/24-customization/","title":"Terminal Customization and Fun","text":""},{"location":"chapters/24-customization/#summary","title":"Summary","text":"<p>This chapter explores the fun side of Linux! Learn to customize your terminal with colorful prompts using PS1 and ANSI color codes, display system information with neofetch, and discover classic Linux easter eggs like cowsay, figlet, and the infamous sl command. A personalized terminal makes daily work more enjoyable.</p>"},{"location":"chapters/24-customization/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 10 concepts from the learning graph:</p> <ol> <li>Terminal Customization</li> <li>Custom Prompts</li> <li>PS1 Variable</li> <li>Terminal Colors</li> <li>ANSI Color Codes</li> <li>Neofetch</li> <li>Cowsay</li> <li>Figlet</li> <li>Sl Command</li> <li>Linux Easter Eggs</li> </ol>"},{"location":"chapters/24-customization/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 2: Getting Started with the Terminal</li> <li>Chapter 11: Shell Configuration and Environment</li> <li>Chapter 14: Package Management</li> </ul> <p>TODO: Generate Chapter Content</p>"},{"location":"chapters/25-capstone/","title":"Capstone Projects","text":""},{"location":"chapters/25-capstone/#summary","title":"Summary","text":"<p>This chapter presents hands-on projects that integrate everything you've learned. Build and deploy web servers with Nginx or Apache, set up game servers like Minecraft, create media servers with Plex or Jellyfin, block ads network-wide with Pi-Hole, configure VPN access with WireGuard, set up retro gaming with RetroPie, and create network storage solutions. Each project reinforces Linux skills while creating something useful.</p>"},{"location":"chapters/25-capstone/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 20 concepts from the learning graph:</p> <ol> <li>Final Projects</li> <li>Web Server Setup</li> <li>Nginx Server</li> <li>Apache Server</li> <li>Game Server</li> <li>Minecraft Server</li> <li>Media Server</li> <li>Plex Server</li> <li>Jellyfin Server</li> <li>Pi-Hole Ad Blocker</li> <li>DNS Server</li> <li>VPN Server</li> <li>WireGuard VPN</li> <li>Retro Gaming</li> <li>RetroPie</li> <li>Network Storage</li> <li>NAS Server</li> <li>Backup Server</li> <li>Monitoring Dashboard</li> <li>Portfolio Project</li> </ol>"},{"location":"chapters/25-capstone/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 13: Shell Scripting and Automation</li> <li>Chapter 15: Networking Fundamentals</li> <li>Chapter 16: SSH and Remote Access</li> <li>Chapter 19: Introduction to Raspberry Pi</li> <li>Chapter 21: Cloud Computing and Containers</li> </ul> <p>TODO: Generate Chapter Content</p>"},{"location":"chapters/26-careers/","title":"Linux Careers and the Future","text":""},{"location":"chapters/26-careers/#summary","title":"Summary","text":"<p>This final chapter explores career opportunities in the Linux ecosystem and looks ahead to the future. Learn about career paths including System Administrator, DevOps Engineer, Network Administrator, and Cloud Engineer. Discover Linux certifications that can boost your credentials, and explore fascinating applications of Linux in space exploration and automotive systems. The chapter concludes with the ongoing evolution from C to Rust in systems programming.</p>"},{"location":"chapters/26-careers/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 10 concepts from the learning graph:</p> <ol> <li>Linux Careers</li> <li>System Administrator</li> <li>DevOps Engineer</li> <li>Network Administrator</li> <li>Cloud Engineer</li> <li>Linux Certifications</li> <li>Linux in Space</li> <li>Linux in Cars</li> <li>C vs Rust</li> <li>Future of Linux</li> </ol>"},{"location":"chapters/26-careers/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 1: Introduction to Operating Systems and UNIX History</li> <li>Chapter 21: Cloud Computing and Containers</li> <li>Chapter 23: System Administration Essentials</li> </ul> <p>TODO: Generate Chapter Content</p>"},{"location":"learning-graph/","title":"Learning Graph","text":"<p>The Learning Graph is the foundational data structure for the Learning Linux intelligent textbook. It maps the relationships between 550 concepts, showing how knowledge builds from foundational ideas to advanced applications.</p> <p>Run the Learning Graph Viewer Fullscreen</p>"},{"location":"learning-graph/#what-is-a-learning-graph","title":"What is a Learning Graph?","text":"<p>A learning graph is a directed acyclic graph (DAG) where:</p> <ul> <li>Nodes represent concepts students need to learn</li> <li>Edges represent prerequisite relationships (\"you should learn A before B\")</li> <li>Groups categorize concepts by topic area</li> </ul> <p>This structure enables:</p> <ul> <li>Adaptive learning paths - Students can follow personalized routes through the material</li> <li>Prerequisite tracking - The system knows what foundations are needed for each topic</li> <li>Progress visualization - Students and instructors can see mastery across the concept map</li> </ul>"},{"location":"learning-graph/#graph-statistics","title":"Graph Statistics","text":"Metric Value Total Concepts 550 Taxonomy Categories 16 Foundational Concepts 8 Maximum Chain Depth 12 Average Dependencies 1.72"},{"location":"learning-graph/#taxonomy-categories","title":"Taxonomy Categories","text":"<p>The concepts are organized into 16 categories:</p> Category Concepts Description History and Philosophy 20 UNIX origins, key figures, Linux distributions Shell Fundamentals 30 Terminal, commands, navigation File System 60 Directories, paths, file operations Permissions 25 Access control, ownership, sudo Text Processing 30 grep, regex, sed, awk, pipes Text Editors 15 Nano, Vim Configuration 20 Dotfiles, environment variables Process Management 40 Processes, scheduling, scripts Package Management 20 APT, Homebrew Networking 50 IP, SSH, security, firewalls Storage 65 Compression, devices, performance Raspberry Pi 65 GPIO, sensors, IoT, automation Cloud 25 Docker, Terraform, deployment Development 25 Git, Python, IDEs Administration 40 Users, services, display, audio Capstone 30 Projects, careers"},{"location":"learning-graph/#files-in-this-section","title":"Files in This Section","text":"<ul> <li>Concept List - Complete list of 550 concepts</li> <li>Concept Taxonomy - Category definitions</li> <li>Quality Metrics - Graph validation report</li> <li>Taxonomy Distribution - Category balance analysis</li> </ul>"},{"location":"learning-graph/#data-files","title":"Data Files","text":"<ul> <li><code>learning-graph.csv</code> - Concepts with dependencies and taxonomy</li> <li><code>learning-graph.json</code> - Complete graph in vis-network.js format</li> <li><code>metadata.json</code> - Dublin Core metadata for the graph</li> </ul>"},{"location":"learning-graph/#using-the-learning-graph","title":"Using the Learning Graph","text":""},{"location":"learning-graph/#for-students","title":"For Students","text":"<p>The learning graph helps you understand:</p> <ol> <li>What concepts you need to learn first (foundational concepts have no arrows pointing to them)</li> <li>How topics connect to each other</li> <li>Multiple paths to reach advanced topics</li> </ol>"},{"location":"learning-graph/#for-instructors","title":"For Instructors","text":"<p>The learning graph supports:</p> <ol> <li>Curriculum planning - See the full scope of topics</li> <li>Prerequisite enforcement - Know what students need before each lesson</li> <li>Progress monitoring - Track mastery across the concept map</li> </ol>"},{"location":"learning-graph/#for-developers","title":"For Developers","text":"<p>The <code>learning-graph.json</code> file can be:</p> <ol> <li>Visualized with vis-network.js</li> <li>Imported into learning management systems</li> <li>Used for adaptive learning algorithms</li> <li>Analyzed for curriculum optimization</li> </ol>"},{"location":"learning-graph/#next-steps","title":"Next Steps","text":"<p>After reviewing the learning graph:</p> <ol> <li>Review concepts - Ensure all important topics are covered</li> <li>Check dependencies - Verify prerequisite relationships make sense</li> <li>Generate chapters - Use the <code>book-chapter-generator</code> skill to create chapter structure</li> <li>Build content - Develop lessons for each concept</li> </ol> <p>Learning Graph generated with Learning Graph Generator v0.03 on 2025-12-06</p>"},{"location":"learning-graph/concept-list/","title":"Learning Linux Concept List","text":"<p>This is a comprehensive list of 300 concepts for the Learning Linux course. Each concept is numbered with a unique ConceptID for use in the learning graph.</p>"},{"location":"learning-graph/concept-list/#history-and-philosophy-1-20","title":"History and Philosophy (1-20)","text":"<ol> <li>Operating System</li> <li>UNIX History</li> <li>Bell Labs</li> <li>Ken Thompson</li> <li>Dennis Ritchie</li> <li>C Programming Language</li> <li>UNIX Philosophy</li> <li>Small Modular Tools</li> <li>Portability</li> <li>Open Source</li> <li>GNU Project</li> <li>Richard Stallman</li> <li>Linux Kernel</li> <li>Linus Torvalds</li> <li>Linux Distributions</li> <li>Debian</li> <li>Ubuntu</li> <li>BSD Unix</li> <li>UNIX System V</li> <li>POSIX Standards</li> </ol>"},{"location":"learning-graph/concept-list/#shell-fundamentals-21-50","title":"Shell Fundamentals (21-50)","text":"<ol> <li>Shell</li> <li>Bash Shell</li> <li>Zsh Shell</li> <li>Terminal Emulator</li> <li>Command Line Interface</li> <li>Shell Prompt</li> <li>Command Syntax</li> <li>Command Arguments</li> <li>Command Options</li> <li>Command Flags</li> <li>Tab Completion</li> <li>Command History</li> <li>History Command</li> <li>Arrow Key Navigation</li> <li>Ctrl Key Shortcuts</li> <li>Clear Command</li> <li>Exit Command</li> <li>Man Pages</li> <li>Help Command</li> <li>Whatis Command</li> <li>Apropos Command</li> <li>Echo Command</li> <li>Printf Command</li> <li>Date Command</li> <li>Cal Command</li> <li>Uptime Command</li> <li>Whoami Command</li> <li>Hostname Command</li> <li>Uname Command</li> <li>Version Information</li> </ol>"},{"location":"learning-graph/concept-list/#file-system-navigation-51-80","title":"File System Navigation (51-80)","text":"<ol> <li>File System</li> <li>Root Directory</li> <li>Home Directory</li> <li>Current Directory</li> <li>Parent Directory</li> <li>Absolute Path</li> <li>Relative Path</li> <li>Pwd Command</li> <li>Cd Command</li> <li>Ls Command</li> <li>Ls Options</li> <li>Hidden Files</li> <li>Dot Files</li> <li>Directory Structure</li> <li>Bin Directory</li> <li>Etc Directory</li> <li>Var Directory</li> <li>Tmp Directory</li> <li>Usr Directory</li> <li>Opt Directory</li> <li>Dev Directory</li> <li>Proc Directory</li> <li>Home Subdirectories</li> <li>Desktop Directory</li> <li>Documents Directory</li> <li>Downloads Directory</li> <li>Tree Command</li> <li>File Command</li> <li>Stat Command</li> <li>Pathnames</li> </ol>"},{"location":"learning-graph/concept-list/#file-operations-81-110","title":"File Operations (81-110)","text":"<ol> <li>Touch Command</li> <li>Mkdir Command</li> <li>Rmdir Command</li> <li>Cp Command</li> <li>Mv Command</li> <li>Rm Command</li> <li>Rm Recursive</li> <li>Cat Command</li> <li>Head Command</li> <li>Tail Command</li> <li>Less Command</li> <li>More Command</li> <li>Wc Command</li> <li>Sort Command</li> <li>Uniq Command</li> <li>Cut Command</li> <li>Paste Command</li> <li>Diff Command</li> <li>Symbolic Links</li> <li>Hard Links</li> <li>Ln Command</li> <li>File Globbing</li> <li>Wildcards</li> <li>Asterisk Wildcard</li> <li>Question Mark Wildcard</li> <li>Bracket Expressions</li> <li>Brace Expansion</li> <li>Tilde Expansion</li> <li>File Attributes</li> <li>File Timestamps</li> </ol>"},{"location":"learning-graph/concept-list/#permissions-and-ownership-111-135","title":"Permissions and Ownership (111-135)","text":"<ol> <li>File Permissions</li> <li>Read Permission</li> <li>Write Permission</li> <li>Execute Permission</li> <li>Owner Permissions</li> <li>Group Permissions</li> <li>Other Permissions</li> <li>Permission Notation</li> <li>Numeric Permissions</li> <li>Chmod Command</li> <li>Chown Command</li> <li>Chgrp Command</li> <li>User Accounts</li> <li>Root User</li> <li>Sudo Command</li> <li>Su Command</li> <li>User Groups</li> <li>Primary Group</li> <li>Secondary Groups</li> <li>Umask Command</li> <li>Default Permissions</li> <li>Setuid Bit</li> <li>Setgid Bit</li> <li>Sticky Bit</li> <li>Special Permissions</li> </ol>"},{"location":"learning-graph/concept-list/#text-processing-136-165","title":"Text Processing (136-165)","text":"<ol> <li>Grep Command</li> <li>Grep Options</li> <li>Regular Expressions</li> <li>Basic Regex</li> <li>Extended Regex</li> <li>Regex Metacharacters</li> <li>Regex Anchors</li> <li>Regex Character Classes</li> <li>Regex Quantifiers</li> <li>Sed Command</li> <li>Sed Substitution</li> <li>Awk Command</li> <li>Awk Fields</li> <li>Awk Patterns</li> <li>Text Streams</li> <li>Standard Input</li> <li>Standard Output</li> <li>Standard Error</li> <li>Redirection</li> <li>Output Redirection</li> <li>Input Redirection</li> <li>Append Redirection</li> <li>Error Redirection</li> <li>Pipe Operator</li> <li>Pipeline Commands</li> <li>Xargs Command</li> <li>Tee Command</li> <li>Tr Command</li> <li>Rev Command</li> <li>Fold Command</li> </ol>"},{"location":"learning-graph/concept-list/#text-editors-166-180","title":"Text Editors (166-180)","text":"<ol> <li>Text Editors</li> <li>Nano Editor</li> <li>Nano Commands</li> <li>Nano Shortcuts</li> <li>Vi Editor</li> <li>Vim Editor</li> <li>Vim Modes</li> <li>Vim Insert Mode</li> <li>Vim Command Mode</li> <li>Vim Visual Mode</li> <li>Vim Navigation</li> <li>Vim Save and Quit</li> <li>Vim Search Replace</li> <li>Vimrc Configuration</li> <li>Editor Selection</li> </ol>"},{"location":"learning-graph/concept-list/#shell-configuration-181-200","title":"Shell Configuration (181-200)","text":"<ol> <li>Shell Configuration</li> <li>Bashrc File</li> <li>Bash Profile</li> <li>Zshrc File</li> <li>Profile File</li> <li>Environment Variables</li> <li>PATH Variable</li> <li>HOME Variable</li> <li>USER Variable</li> <li>SHELL Variable</li> <li>Export Command</li> <li>Source Command</li> <li>Alias Command</li> <li>Creating Aliases</li> <li>Removing Aliases</li> <li>Shell Functions</li> <li>Shell Startup Order</li> <li>Login Shell</li> <li>Interactive Shell</li> <li>Non-Interactive Shell</li> </ol>"},{"location":"learning-graph/concept-list/#process-management-201-225","title":"Process Management (201-225)","text":"<ol> <li>Processes</li> <li>Process ID</li> <li>Parent Process</li> <li>Child Process</li> <li>Foreground Process</li> <li>Background Process</li> <li>Ps Command</li> <li>Ps Options</li> <li>Top Command</li> <li>Htop Command</li> <li>Kill Command</li> <li>Kill Signals</li> <li>Killall Command</li> <li>Pkill Command</li> <li>Jobs Command</li> <li>Fg Command</li> <li>Bg Command</li> <li>Nohup Command</li> <li>Ampersand Operator</li> <li>Process Priority</li> <li>Nice Command</li> <li>Renice Command</li> <li>Pgrep Command</li> <li>Process States</li> <li>Zombie Processes</li> </ol>"},{"location":"learning-graph/concept-list/#package-management-226-245","title":"Package Management (226-245)","text":"<ol> <li>Package Manager</li> <li>Software Packages</li> <li>Package Repositories</li> <li>APT Package Manager</li> <li>Apt Update</li> <li>Apt Upgrade</li> <li>Apt Install</li> <li>Apt Remove</li> <li>Apt Search</li> <li>Apt Show</li> <li>Dpkg Command</li> <li>Snap Packages</li> <li>Flatpak</li> <li>Homebrew</li> <li>Brew Install</li> <li>Brew Update</li> <li>Package Dependencies</li> <li>Repository Sources</li> <li>PPA Repositories</li> <li>Software Updates</li> </ol>"},{"location":"learning-graph/concept-list/#networking-246-270","title":"Networking (246-270)","text":"<ol> <li>Network Basics</li> <li>IP Address</li> <li>MAC Address</li> <li>DNS</li> <li>Hostname Resolution</li> <li>Network Interfaces</li> <li>Ifconfig Command</li> <li>Ip Command</li> <li>Ping Command</li> <li>Traceroute Command</li> <li>Netstat Command</li> <li>Ss Command</li> <li>Curl Command</li> <li>Wget Command</li> <li>SSH Protocol</li> <li>SSH Command</li> <li>SSH Keys</li> <li>SSH Config</li> <li>SCP Command</li> <li>Rsync Command</li> <li>Firewall Basics</li> <li>UFW Firewall</li> <li>Network Ports</li> <li>WiFi Configuration</li> <li>Network Troubleshooting</li> </ol>"},{"location":"learning-graph/concept-list/#compression-and-archives-271-285","title":"Compression and Archives (271-285)","text":"<ol> <li>File Compression</li> <li>Gzip Command</li> <li>Gunzip Command</li> <li>Bzip2 Command</li> <li>Xz Command</li> <li>Tar Command</li> <li>Tar Create</li> <li>Tar Extract</li> <li>Tar Options</li> <li>Zip Command</li> <li>Unzip Command</li> <li>Archive Formats</li> <li>Compression Ratios</li> <li>7zip Command</li> <li>File Archiving</li> </ol>"},{"location":"learning-graph/concept-list/#search-and-find-286-300","title":"Search and Find (286-300)","text":"<ol> <li>Find Command</li> <li>Find by Name</li> <li>Find by Type</li> <li>Find by Size</li> <li>Find by Time</li> <li>Find with Exec</li> <li>Locate Command</li> <li>Updatedb Command</li> <li>Which Command</li> <li>Whereis Command</li> <li>Type Command</li> <li>File Search Patterns</li> <li>Recursive Search</li> <li>Search Optimization</li> <li>Index Databases</li> </ol>"},{"location":"learning-graph/concept-list/#scheduling-and-automation-301-315","title":"Scheduling and Automation (301-315)","text":"<ol> <li>Cron Daemon</li> <li>Crontab Command</li> <li>Cron Syntax</li> <li>Cron Schedule Fields</li> <li>Cron Examples</li> <li>At Command</li> <li>Batch Command</li> <li>Systemd Timers</li> <li>Anacron</li> <li>Shell Scripts</li> <li>Script Shebang</li> <li>Script Permissions</li> <li>Script Variables</li> <li>Script Arguments</li> <li>Script Exit Codes</li> </ol>"},{"location":"learning-graph/concept-list/#storage-and-devices-316-335","title":"Storage and Devices (316-335)","text":"<ol> <li>Storage Devices</li> <li>Block Devices</li> <li>Character Devices</li> <li>Device Files</li> <li>Mount Command</li> <li>Umount Command</li> <li>Fstab File</li> <li>Disk Partitions</li> <li>Fdisk Command</li> <li>Lsblk Command</li> <li>Df Command</li> <li>Du Command</li> <li>USB Drives</li> <li>Flash Drives</li> <li>Swap Space</li> <li>Swap File</li> <li>Swap Partition</li> <li>File System Types</li> <li>Ext4 File System</li> <li>NTFS Support</li> </ol>"},{"location":"learning-graph/concept-list/#performance-monitoring-336-350","title":"Performance Monitoring (336-350)","text":"<ol> <li>System Monitoring</li> <li>CPU Usage</li> <li>Memory Usage</li> <li>Disk Usage</li> <li>Free Command</li> <li>Vmstat Command</li> <li>Iostat Command</li> <li>Sar Command</li> <li>Performance Tuning</li> <li>CPU Benchmarks</li> <li>Disk Benchmarks</li> <li>GPU Performance</li> <li>System Load</li> <li>Load Average</li> <li>Bottleneck Analysis</li> </ol>"},{"location":"learning-graph/concept-list/#raspberry-pi-basics-351-375","title":"Raspberry Pi Basics (351-375)","text":"<ol> <li>Raspberry Pi</li> <li>Raspberry Pi Models</li> <li>Raspberry Pi Zero</li> <li>Raspberry Pi 4</li> <li>Raspberry Pi 5</li> <li>Raspberry Pi 500</li> <li>Raspberry Pi OS</li> <li>Pi Imager</li> <li>SD Card Setup</li> <li>Pi First Boot</li> <li>Raspi-Config</li> <li>Pi Desktop</li> <li>Pi Terminal</li> <li>Pi GPIO Header</li> <li>GPIO Pins</li> <li>GPIO Voltage</li> <li>GPIO Ground Pins</li> <li>GPIO Power Pins</li> <li>GPIO Data Pins</li> <li>Pi Camera Module</li> <li>Pi USB Ports</li> <li>Pi HDMI Ports</li> <li>Pi Ethernet Port</li> <li>Pi WiFi</li> <li>Pi Bluetooth</li> </ol>"},{"location":"learning-graph/concept-list/#gpio-and-hardware-376-395","title":"GPIO and Hardware (376-395)","text":"<ol> <li>GPIO Programming</li> <li>GPIO Input</li> <li>GPIO Output</li> <li>Digital Signals</li> <li>PWM Signals</li> <li>LED Control</li> <li>LED Strip</li> <li>NeoPixel LEDs</li> <li>Button Input</li> <li>Sensor Reading</li> <li>Temperature Sensor</li> <li>Motion Sensor</li> <li>Light Sensor</li> <li>Motor Control</li> <li>DC Motors</li> <li>Servo Motors</li> <li>Stepper Motors</li> <li>Motor Drivers</li> <li>External Power</li> <li>Current Monitoring</li> </ol>"},{"location":"learning-graph/concept-list/#iot-and-home-automation-396-415","title":"IoT and Home Automation (396-415)","text":"<ol> <li>Internet of Things</li> <li>IoT Sensors</li> <li>IoT Protocols</li> <li>MQTT Protocol</li> <li>Home Automation</li> <li>Smart Home Hub</li> <li>Home Monitoring</li> <li>Temperature Logging</li> <li>Security Cameras</li> <li>Motion Detection</li> <li>Remote Access</li> <li>Web Dashboard</li> <li>Data Logging</li> <li>Time Series Data</li> <li>Alerts and Notifications</li> <li>Home Assistant</li> <li>Node-RED</li> <li>IFTTT Integration</li> <li>Voice Control</li> <li>Automation Scripts</li> </ol>"},{"location":"learning-graph/concept-list/#cloud-and-containers-416-440","title":"Cloud and Containers (416-440)","text":"<ol> <li>Cloud Computing</li> <li>Virtual Machines</li> <li>Cloud Providers</li> <li>AWS Basics</li> <li>Cloud Linux Instances</li> <li>SSH to Cloud</li> <li>Docker</li> <li>Docker Images</li> <li>Docker Containers</li> <li>Docker Commands</li> <li>Docker Run</li> <li>Docker Build</li> <li>Dockerfile</li> <li>Docker Compose</li> <li>Container Networking</li> <li>Container Volumes</li> <li>Terraform Basics</li> <li>Infrastructure as Code</li> <li>Terraform Providers</li> <li>Terraform Resources</li> <li>Cloud Deployment</li> <li>Container Registry</li> <li>Microservices</li> <li>Cloud Security</li> <li>Cost Management</li> </ol>"},{"location":"learning-graph/concept-list/#development-tools-441-465","title":"Development Tools (441-465)","text":"<ol> <li>Version Control</li> <li>Git Basics</li> <li>Git Init</li> <li>Git Clone</li> <li>Git Add</li> <li>Git Commit</li> <li>Git Push</li> <li>Git Pull</li> <li>Git Branch</li> <li>Git Merge</li> <li>GitHub</li> <li>GitHub Repositories</li> <li>GitHub SSH Keys</li> <li>Python on Linux</li> <li>Python3 Command</li> <li>Pip Package Manager</li> <li>Virtual Environments</li> <li>Venv Module</li> <li>Conda Environment</li> <li>VSCode on Linux</li> <li>Thonny IDE</li> <li>Code Editors</li> <li>Debugging Tools</li> <li>GDB Debugger</li> <li>Print Debugging</li> </ol>"},{"location":"learning-graph/concept-list/#security-basics-466-480","title":"Security Basics (466-480)","text":"<ol> <li>Linux Security</li> <li>User Authentication</li> <li>Password Security</li> <li>SSH Security</li> <li>Key-Based Auth</li> <li>Firewall Rules</li> <li>Port Security</li> <li>File Encryption</li> <li>GPG Encryption</li> <li>Secure File Transfer</li> <li>Security Updates</li> <li>Vulnerability Scanning</li> <li>Log Files</li> <li>Audit Logs</li> <li>Security Best Practices</li> </ol>"},{"location":"learning-graph/concept-list/#system-administration-481-495","title":"System Administration (481-495)","text":"<ol> <li>System Administration</li> <li>User Management</li> <li>Useradd Command</li> <li>Usermod Command</li> <li>Userdel Command</li> <li>Group Management</li> <li>Password Management</li> <li>Passwd Command</li> <li>Shutdown Command</li> <li>Reboot Command</li> <li>System Services</li> <li>Systemctl Command</li> <li>Service Status</li> <li>Service Start Stop</li> <li>Boot Process</li> </ol>"},{"location":"learning-graph/concept-list/#display-and-audio-496-510","title":"Display and Audio (496-510)","text":"<ol> <li>Display Configuration</li> <li>HDMI Output</li> <li>Multiple Displays</li> <li>Display Resolution</li> <li>Screen Command</li> <li>Tmux Multiplexer</li> <li>Audio Configuration</li> <li>ALSA Audio</li> <li>PulseAudio</li> <li>Volume Control</li> <li>Audio Output</li> <li>Bluetooth Audio</li> <li>USB Audio</li> <li>Sound Testing</li> <li>Audio Troubleshooting</li> </ol>"},{"location":"learning-graph/concept-list/#fun-and-easter-eggs-511-520","title":"Fun and Easter Eggs (511-520)","text":"<ol> <li>Terminal Customization</li> <li>Custom Prompts</li> <li>PS1 Variable</li> <li>Terminal Colors</li> <li>ANSI Color Codes</li> <li>Neofetch</li> <li>Cowsay</li> <li>Figlet</li> <li>Sl Command</li> <li>Linux Easter Eggs</li> </ol>"},{"location":"learning-graph/concept-list/#capstone-projects-521-540","title":"Capstone Projects (521-540)","text":"<ol> <li>Final Projects</li> <li>Web Server Setup</li> <li>Nginx Server</li> <li>Apache Server</li> <li>Game Server</li> <li>Minecraft Server</li> <li>Media Server</li> <li>Plex Server</li> <li>Jellyfin Server</li> <li>Pi-Hole Ad Blocker</li> <li>DNS Server</li> <li>VPN Server</li> <li>WireGuard VPN</li> <li>Retro Gaming</li> <li>RetroPie</li> <li>Network Storage</li> <li>NAS Server</li> <li>Backup Server</li> <li>Monitoring Dashboard</li> <li>Portfolio Project</li> </ol>"},{"location":"learning-graph/concept-list/#career-and-future-541-550","title":"Career and Future (541-550)","text":"<ol> <li>Linux Careers</li> <li>System Administrator</li> <li>DevOps Engineer</li> <li>Network Administrator</li> <li>Cloud Engineer</li> <li>Linux Certifications</li> <li>Linux in Space</li> <li>Linux in Cars</li> <li>C vs Rust</li> <li>Future of Linux</li> </ol>"},{"location":"learning-graph/concept-taxonomy/","title":"Learning Linux Concept Taxonomy","text":"<p>This document defines the 12 taxonomy categories used to classify concepts in the Learning Linux learning graph.</p>"},{"location":"learning-graph/concept-taxonomy/#taxonomy-categories","title":"Taxonomy Categories","text":"TaxonomyID Category Name Description Concept Range HIST History and Philosophy UNIX/Linux origins, key figures, design philosophy, and distributions 1-20 SHELL Shell Fundamentals Terminal, command line, shell basics, and basic commands 21-50 FSYS File System Navigation, paths, directories, file operations 51-110 PERM Permissions and Security File permissions, ownership, user accounts, sudo 111-135 TEXT Text Processing Grep, regex, sed, awk, streams, pipes, redirection 136-165 EDIT Text Editors Nano, Vim, editor configuration 166-180 CONF Configuration Shell configuration, dotfiles, environment variables, aliases 181-200 PROC Process Management Processes, signals, job control, scheduling 201-225, 301-315 PKG Package Management APT, Homebrew, software installation, updates 226-245 NET Networking IP, DNS, SSH, firewalls, network commands 246-270, 466-480 STOR Storage and Performance Compression, archives, devices, mounting, monitoring 271-300, 316-350 RPI Raspberry Pi Pi models, GPIO, hardware, IoT, home automation 351-415 CLOUD Cloud and Containers Docker, Terraform, cloud computing, deployment 416-440 DEV Development Tools Git, GitHub, Python, IDEs, debugging 441-465 ADMIN System Administration User management, services, boot, display, audio 481-520 CAP Capstone Projects Final projects, servers, career topics 521-550"},{"location":"learning-graph/concept-taxonomy/#category-descriptions","title":"Category Descriptions","text":""},{"location":"learning-graph/concept-taxonomy/#hist-history-and-philosophy","title":"HIST - History and Philosophy","text":"<p>Concepts covering the historical development of UNIX and Linux, key contributors like Ken Thompson, Dennis Ritchie, Richard Stallman, and Linus Torvalds, the UNIX philosophy of small modular tools, open source movement, and major Linux distributions.</p>"},{"location":"learning-graph/concept-taxonomy/#shell-shell-fundamentals","title":"SHELL - Shell Fundamentals","text":"<p>Core concepts for working with the terminal including Bash and Zsh shells, command syntax, options and arguments, tab completion, command history, man pages, and basic system information commands.</p>"},{"location":"learning-graph/concept-taxonomy/#fsys-file-system","title":"FSYS - File System","text":"<p>Everything related to navigating and manipulating files including the directory hierarchy, absolute and relative paths, file operations (copy, move, delete), file attributes, wildcards, and file globbing patterns.</p>"},{"location":"learning-graph/concept-taxonomy/#perm-permissions-and-security","title":"PERM - Permissions and Security","text":"<p>File permission system including read/write/execute permissions, numeric notation, chmod/chown/chgrp commands, user accounts, root access, sudo, and special permission bits.</p>"},{"location":"learning-graph/concept-taxonomy/#text-text-processing","title":"TEXT - Text Processing","text":"<p>Tools for searching and manipulating text including grep, regular expressions, sed, awk, text streams, standard input/output/error, redirection operators, and pipe-based command pipelines.</p>"},{"location":"learning-graph/concept-taxonomy/#edit-text-editors","title":"EDIT - Text Editors","text":"<p>Terminal-based text editors including Nano for beginners and Vim for power users, covering modes, commands, navigation, and configuration files.</p>"},{"location":"learning-graph/concept-taxonomy/#conf-configuration","title":"CONF - Configuration","text":"<p>Shell customization including dotfiles (.bashrc, .zshrc), environment variables (PATH, HOME), aliases, shell functions, and startup scripts.</p>"},{"location":"learning-graph/concept-taxonomy/#proc-process-management","title":"PROC - Process Management","text":"<p>Understanding and controlling running programs including process IDs, foreground/background processes, job control, kill signals, cron scheduling, and shell scripting.</p>"},{"location":"learning-graph/concept-taxonomy/#pkg-package-management","title":"PKG - Package Management","text":"<p>Installing and managing software using package managers like APT (Debian/Ubuntu), Homebrew (macOS), and related package formats.</p>"},{"location":"learning-graph/concept-taxonomy/#net-networking","title":"NET - Networking","text":"<p>Network fundamentals and remote access including IP addressing, DNS, SSH connections, key-based authentication, firewalls, and network diagnostic tools.</p>"},{"location":"learning-graph/concept-taxonomy/#stor-storage-and-performance","title":"STOR - Storage and Performance","text":"<p>Disk and file management including compression tools, archive formats, storage devices, mounting, file system types, and system performance monitoring.</p>"},{"location":"learning-graph/concept-taxonomy/#rpi-raspberry-pi","title":"RPI - Raspberry Pi","text":"<p>Raspberry Pi specific topics including hardware models, GPIO programming, sensors, motors, LEDs, IoT projects, and home automation.</p>"},{"location":"learning-graph/concept-taxonomy/#cloud-cloud-and-containers","title":"CLOUD - Cloud and Containers","text":"<p>Modern deployment technologies including Docker containers, cloud computing basics, Terraform infrastructure-as-code, and microservices.</p>"},{"location":"learning-graph/concept-taxonomy/#dev-development-tools","title":"DEV - Development Tools","text":"<p>Software development workflow including Git version control, GitHub, Python programming environment, IDEs, and debugging tools.</p>"},{"location":"learning-graph/concept-taxonomy/#admin-system-administration","title":"ADMIN - System Administration","text":"<p>System management tasks including user/group management, system services, boot process, display configuration, and audio setup.</p>"},{"location":"learning-graph/concept-taxonomy/#cap-capstone-projects","title":"CAP - Capstone Projects","text":"<p>Hands-on final projects and career-related topics including web servers, game servers, media servers, network tools, and Linux career paths.</p>"},{"location":"learning-graph/quality-metrics/","title":"Learning Graph Quality Metrics Report","text":""},{"location":"learning-graph/quality-metrics/#overview","title":"Overview","text":"<ul> <li>Total Concepts: 550</li> <li>Foundational Concepts (no dependencies): 8</li> <li>Concepts with Dependencies: 542</li> <li>Average Dependencies per Concept: 1.72</li> </ul>"},{"location":"learning-graph/quality-metrics/#graph-structure-validation","title":"Graph Structure Validation","text":"<ul> <li>Valid DAG Structure: \u2705 Yes</li> <li>Self-Dependencies: None detected \u2705</li> <li>Cycles Detected: 0</li> </ul>"},{"location":"learning-graph/quality-metrics/#foundational-concepts","title":"Foundational Concepts","text":"<p>These concepts have no prerequisites:</p> <ul> <li>1: Operating System</li> <li>51: File System</li> <li>246: Network Basics</li> <li>316: Storage Devices</li> <li>466: Linux Security</li> <li>481: System Administration</li> <li>496: Display Configuration</li> <li>502: Audio Configuration</li> </ul>"},{"location":"learning-graph/quality-metrics/#dependency-chain-analysis","title":"Dependency Chain Analysis","text":"<ul> <li>Maximum Dependency Chain Length: 12</li> </ul>"},{"location":"learning-graph/quality-metrics/#longest-learning-path","title":"Longest Learning Path:","text":"<ol> <li>Operating System (ID: 1)</li> <li>UNIX History (ID: 2)</li> <li>UNIX Philosophy (ID: 7)</li> <li>Open Source (ID: 10)</li> <li>GNU Project (ID: 11)</li> <li>Linux Kernel (ID: 13)</li> <li>Linux Distributions (ID: 15)</li> <li>Debian (ID: 16)</li> <li>Ubuntu (ID: 17)</li> <li>PPA Repositories (ID: 244)</li> <li>Repository Sources (ID: 243)</li> <li>Package Repositories (ID: 228)</li> </ol>"},{"location":"learning-graph/quality-metrics/#orphaned-nodes-analysis","title":"Orphaned Nodes Analysis","text":"<ul> <li>Total Orphaned Nodes: 185</li> </ul> <p>Many terminal concepts (capstone projects, career topics) are intentionally orphaned as they represent end goals.</p> <p>Examples of orphaned nodes:</p> <ul> <li>540: Portfolio Project</li> <li>550: Future of Linux</li> <li>548: Linux in Cars</li> <li>547: Linux in Space</li> <li>546: Linux Certifications</li> <li>545: Cloud Engineer</li> <li>544: Network Administrator</li> <li>543: DevOps Engineer</li> <li>542: System Administrator</li> <li>541: Linux Careers</li> <li>539: Monitoring Dashboard</li> <li>538: Backup Server</li> <li>537: NAS Server</li> <li>536: Network Storage</li> <li>535: RetroPie</li> <li>534: Retro Gaming</li> <li>533: WireGuard VPN</li> <li>532: VPN Server</li> <li>531: DNS Server</li> <li>530: Pi-Hole Ad Blocker</li> </ul> <p>...and 165 more terminal concepts</p>"},{"location":"learning-graph/quality-metrics/#connected-components","title":"Connected Components","text":"<ul> <li>Number of Connected Components: 1</li> </ul> <p>\u2705 All concepts are connected in a single graph.</p>"},{"location":"learning-graph/quality-metrics/#indegree-analysis","title":"Indegree Analysis","text":"<p>Top 10 concepts that are prerequisites for the most other concepts:</p> Rank Concept ID Concept Label Indegree 1 1 Operating System 12 2 51 File System 28 3 21 Shell 18 4 27 Command Syntax 14 5 88 Cat Command 16 6 246 Network Basics 14 7 201 Processes 16 8 316 Storage Devices 10 9 351 Raspberry Pi 18 10 186 Environment Variables 8"},{"location":"learning-graph/quality-metrics/#outdegree-distribution","title":"Outdegree Distribution","text":"Dependencies Number of Concepts 0 8 1 298 2 172 3 52 4 16 5 4"},{"location":"learning-graph/quality-metrics/#quality-score","title":"Quality Score","text":"<p>Based on the analysis:</p> <ul> <li>\u2705 DAG structure verified (no cycles)</li> <li>\u2705 Single connected component (all concepts reachable)</li> <li>\u2705 Strong foundational concepts (8 root nodes)</li> <li>\u2705 Good average dependencies (1.72)</li> <li>\u2705 Reasonable chain depth (12 levels)</li> <li>\u2139\ufe0f Many terminal nodes (expected for capstone-heavy course)</li> </ul> <p>Overall Quality Score: 88/100</p>"},{"location":"learning-graph/quality-metrics/#recommendations","title":"Recommendations","text":"<ul> <li>\u2705 DAG structure verified: Graph supports valid learning progressions</li> <li>\u2705 Well-connected graph: All concepts are part of one connected component</li> <li>\u2139\ufe0f Terminal concepts are appropriate: Capstone projects and career topics should be orphaned</li> <li>\u2139\ufe0f Consider cross-topic dependencies: Some advanced topics could reference foundational concepts from other domains</li> </ul> <p>Report generated for Learning Linux course - 550 concepts</p>"},{"location":"learning-graph/taxonomy-distribution/","title":"Taxonomy Distribution Report","text":"<p>This report analyzes the distribution of concepts across taxonomy categories in the Learning Linux learning graph.</p>"},{"location":"learning-graph/taxonomy-distribution/#distribution-summary","title":"Distribution Summary","text":"Category Name TaxonomyID Count Percentage History and Philosophy HIST 20 3.6% Shell Fundamentals SHELL 30 5.5% File System FSYS 60 10.9% Permissions and Security PERM 25 4.5% Text Processing TEXT 30 5.5% Text Editors EDIT 15 2.7% Configuration CONF 20 3.6% Process Management PROC 40 7.3% Package Management PKG 20 3.6% Networking NET 50 9.1% Storage and Performance STOR 65 11.8% Raspberry Pi RPI 65 11.8% Cloud and Containers CLOUD 25 4.5% Development Tools DEV 25 4.5% System Administration ADMIN 40 7.3% Capstone Projects CAP 30 5.5% Total 550 100%"},{"location":"learning-graph/taxonomy-distribution/#distribution-visualization","title":"Distribution Visualization","text":"<pre><code>HIST   \u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591  3.6%\nSHELL  \u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591  5.5%\nFSYS   \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 10.9%\nPERM   \u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591  4.5%\nTEXT   \u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591  5.5%\nEDIT   \u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591  2.7%\nCONF   \u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591  3.6%\nPROC   \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591  7.3%\nPKG    \u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591  3.6%\nNET    \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591  9.1%\nSTOR   \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 11.8%\nRPI    \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 11.8%\nCLOUD  \u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591  4.5%\nDEV    \u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591  4.5%\nADMIN  \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591  7.3%\nCAP    \u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591  5.5%\n</code></pre>"},{"location":"learning-graph/taxonomy-distribution/#analysis","title":"Analysis","text":""},{"location":"learning-graph/taxonomy-distribution/#distribution-quality","title":"Distribution Quality","text":"<p>\u2705 No category exceeds 30% - All categories are within acceptable bounds.</p> <p>\u2705 Even distribution - The largest categories (STOR, RPI) are at 11.8%, well below the 30% threshold.</p> <p>\u2705 Logical grouping - Concepts are organized into pedagogically meaningful categories.</p>"},{"location":"learning-graph/taxonomy-distribution/#category-insights","title":"Category Insights","text":"<p>Largest Categories (&gt;10%):</p> <ul> <li>Storage and Performance (STOR): 65 concepts (11.8%) - Includes compression, archives, file search, devices, and performance monitoring</li> <li>Raspberry Pi (RPI): 65 concepts (11.8%) - Covers Pi hardware, GPIO, sensors, motors, and IoT/home automation</li> <li>File System (FSYS): 60 concepts (10.9%) - Navigation, file operations, paths, and globbing</li> </ul> <p>Medium Categories (5-10%):</p> <ul> <li>Networking (NET): 50 concepts (9.1%) - Network commands, SSH, security, firewalls</li> <li>Process Management (PROC): 40 concepts (7.3%) - Processes, scheduling, shell scripts</li> <li>System Administration (ADMIN): 40 concepts (7.3%) - User management, services, display, audio</li> <li>Shell Fundamentals (SHELL): 30 concepts (5.5%) - Terminal basics, command structure</li> <li>Text Processing (TEXT): 30 concepts (5.5%) - grep, regex, sed, awk, pipes</li> <li>Capstone Projects (CAP): 30 concepts (5.5%) - Final projects and career topics</li> </ul> <p>Smaller Categories (&lt;5%):</p> <ul> <li>Permissions (PERM): 25 concepts (4.5%)</li> <li>Cloud (CLOUD): 25 concepts (4.5%)</li> <li>Development Tools (DEV): 25 concepts (4.5%)</li> <li>History (HIST): 20 concepts (3.6%)</li> <li>Configuration (CONF): 20 concepts (3.6%)</li> <li>Package Management (PKG): 20 concepts (3.6%)</li> <li>Text Editors (EDIT): 15 concepts (2.7%)</li> </ul>"},{"location":"learning-graph/taxonomy-distribution/#recommendations","title":"Recommendations","text":"<ol> <li>Distribution is healthy - No rebalancing needed</li> <li>STOR and RPI are appropriate - These are core topics for the course</li> <li>Smaller categories are focused - EDIT (15) is appropriately sized for text editor coverage</li> </ol> <p>Report generated for Learning Linux - 550 concepts across 16 categories</p>"},{"location":"prompts/","title":"List of Prompts","text":"<p>Bloom Taxonomy</p> <p>Book Icon</p> <p>Book Cover</p> <p>Chapter Content</p>"},{"location":"prompts/bloom-taxonomy/","title":"Bloom Taxonomy","text":"<p>Please review the @docs/course-description.md and at the end, add ## Learning Objectives classified according to  the 2001 Bloom Taxonomy </p> <p>Prompt</p> <p>Run the course-description-analyzer skill</p>"},{"location":"prompts/book-icon/","title":"Generating the Book Icon and Logo","text":"<p>Prompt</p> <p>Generate a minimalistic icon/logo that can be used as a favicon for a book on Learning Linux.  Use the \"tux\" icon with an indigo background.  Do not use any text.  Use a square format.</p>"},{"location":"prompts/chapter-content/","title":"Chapter Content","text":"<p>Prompt</p> <p>Use the chapter-content-generator skill to write chapter 1 @docs/chapters/01-unix-history/index.md Use a fun informal tone as though you are having a conversation with a high-school student that is curious about Linux. Feel free to and puns and jokes to break up the text. Make the text compelling and encouraging people to take the journey to become a master of Linux. Log your progress on this session to logs/ch-01.md</p> <p>Prompt</p> <p>Use the chapter-content-generator skill to write chapter 2 @docs/chapters/02-terminal-basics/index.md Maintain a fun informal tone as though you are having a conversation with a high-school student that is curious about Linux. Feel free to and puns and jokes to break up the text. Make the text compelling and encouraging people to take the journey to become a master of Linux. Log your progress on this session to logs/ch-02.md</p> <p>Prompt</p> <p>Use the chapter-content-generator skill to write chapter 3 @docs/chapters/03-shell-commands/index.md Maintain a fun informal tone as though you are having a conversation with a high-school student that is curious about Linux. Feel free to and puns and jokes to break up the text. Make the text compelling and encouraging people to take the journey to become a master of Linux. Log your progress on this session to logs/ch-03.md</p> <p>Prompt</p> <p>Use the chapter-content-generator skill to write chapter 4 @docs/chapters/04-file-system/index.md Maintain a fun informal tone as though you are having a conversation with a high-school student that is curious about Linux. Feel free to and puns and jokes to break up the text. Make the text compelling and encouraging people to take the journey to become a master of Linux. Log your progress on this session to logs/ch-04.md Do not add spaces or tabs inside the  elements. <p>Prompt</p> <p>Use the chapter-content-generator skill to write chapter 5 @docs/chapters/05-file-operations/index.md Maintain a fun informal tone as though you are having a conversation with a high-school student that is curious about Linux. Feel free to and puns and jokes to break up the text. Make the text compelling and encouraging people to take the journey to become a master of Linux. Log your progress on this session to logs/ch-05.md Do not add spaces or tabs inside the  elements."},{"location":"prompts/cover-image/","title":"Cover Image","text":"<p>create a detailed description of a cover image for this course.  The image must be a wide-landscape image using a  1.91:1 ratio to be used on a social media preview.  The title \"Learning Linux\" should be in the center in a white  font on a dark background with padding.  Around the title is a montage collage of the images about the history and  importance of Linux.  Add a logo of Bell Labs back in the 1980.  The collage should have images that are derived from  the course description @docs/course-description.md </p>"},{"location":"prompts/cover-image/#result","title":"Result","text":"<p>Please generate a book cover image for a book on Learning Linux.</p> <p>Wide landscape social media banner (1.91:1 ratio), dark slate gray center with \"Learning Linux\" in large white bold sans-serif text, surrounded by a montage collage of: vintage Bell Labs logo from 1980s, Ken Thompson and Dennis Ritchie at terminal, Tux Linux penguin, Raspberry Pi 500 keyboard computer, terminal windows with green text, circuit boards, GPIO pins with LEDs, Docker whale, server racks, SSH network connections, code editor windows. Blue-indigo color tint overlay unifying all images, vignette effect darkening edges, professional tech education aesthetic, high contrast, modern and retro elements blended</p> <p>## Technical Image Specifications</p> <ul> <li>Aspect Ratio: 1.91:1 (landscape)</li> <li>Recommended Dimensions: 1200 x 628 pixels (standard social media preview)</li> <li>Format: PNG or JPG</li> </ul>"},{"location":"prompts/cover-image/#overall-composition","title":"Overall Composition","text":"<p>The image is divided into a center title zone surrounded by a montage collage border featuring iconic imagery from   Linux history and the course topics.</p>"},{"location":"prompts/cover-image/#center-title-zone","title":"Center Title Zone","text":"<p>Background: Dark slate gray (#1a1a2e) with subtle gradient darkening toward edges</p> <p>Title Treatment:   - Text: \"Learning Linux\"   - Font: Bold sans-serif (similar to Ubuntu or Source Sans Pro)   - Color: Pure white (#FFFFFF)   - Size: Large, prominently centered   - Padding: A small amount dark space around text (approximately 3% margin on all sides)   - Optional: Subtle drop shadow or glow for depth</p>"},{"location":"prompts/cover-image/#montage-collage-border","title":"Montage Collage Border","text":"<p>The collage surrounds the center title zone with overlapping, semi-transparent images at varying opacities (40-70%) to create depth without overwhelming the title. Images should have a slight blue/indigo tint overlay to unify the color palette.</p>"},{"location":"prompts/cover-image/#left-side-history-origins","title":"Left Side - History &amp; Origins","text":"<ol> <li>Bell Labs Logo (1969-1983 era) - The iconic bell-in-circle logo representing where UNIX was born</li> <li>Ken Thompson and Dennis Ritchie - Black and white photo of the UNIX creators at a PDP-11 terminal</li> <li>Vintage terminal/teletype machine - Green phosphor CRT display showing command line</li> <li>The \"C Programming Language\" book cover - Kernighan &amp; Ritchie's classic white book</li> </ol> <p>## Top Section - Linux &amp; Open Source</p> <ol> <li>Tux the Penguin - The Linux mascot, slightly stylized</li> <li>Linus Torvalds - Portrait or silhouette of the Linux creator</li> <li>GNU Logo - The wildebeest representing the GNU Project</li> <li>Binary code streams - Matrix-style falling 1s and 0s</li> </ol> <p>## Right Side - Modern Applications</p> <ol> <li>Raspberry Pi 500+ device - The keyboard computer featured in the course</li> <li>GPIO pins and LED strips - Colorful electronics and maker projects</li> <li>Docker whale logo - Representing containers and cloud</li> <li>Server rack - Modern data center imagery</li> <li>Terminal window - Modern terminal showing colorful command output (ls, grep, etc.)</li> </ol> <p>## Bottom Section - Hands-On Learning</p> <ol> <li>Circuit board patterns - Abstract PCB traces in green/gold</li> <li>SSH connection visualization - Network nodes connected by lines</li> <li>Code editor (VSCode) - Screenshot showing Python/shell script</li> <li>IoT sensors and devices - Temperature sensors, motors, home automation</li> <li>Cloud infrastructure icons - Terraform, AWS, abstract cloud shapes</li> </ol>"},{"location":"prompts/cover-image/#color-palette","title":"Color Palette","text":"Element Color Hex Code Title background Dark slate #1a1a2e Title text White #FFFFFF Accent/overlay tint Indigo #3F51B5 Secondary accent Raspberry Pi red #C51A4A Highlight Terminal green #00FF00 Warm accent Ubuntu orange #E95420"},{"location":"prompts/cover-image/#visual-style-notes","title":"Visual Style Notes","text":"<ul> <li>Opacity layering: Background images at 30-50% opacity, mid-ground at 50-70%</li> <li>Vignette effect: Darker edges drawing eye to center title</li> <li>Unified color grading: Cool blue-indigo tint across all collage elements</li> <li>Depth: Subtle parallax effect with larger images behind, smaller icons in front</li> <li>Professional polish: Clean edges where collage meets title zone, possibly with soft fade</li> </ul>"},{"location":"prompts/cover-image/#symbolic-elements-to-include","title":"Symbolic Elements to Include","text":"<ol> <li>Terminal prompt ($ or &gt;) - Representing command-line interface</li> <li>Penguin silhouette - Linux identity</li> <li>Bell shape - Nod to Bell Labs origins</li> <li>Pi symbol (\u03c0) - Raspberry Pi reference</li> <li>Gear/cog icons - System administration</li> <li>Network topology lines - Connectivity and networking</li> </ol>"},{"location":"sims/graph-viewer/","title":"Learning Graph Viewer","text":"<p>Run the Learning Graph Viewer</p> <p>This viewer reads learning graph data from learning-graph.json:</p> <ol> <li>Search Functionality - Quick node lookup with autocomplete</li> <li>Taxonomy Legend Controls - Filter nodes by category/taxonomy</li> </ol>"},{"location":"sims/graph-viewer/#features","title":"Features","text":""},{"location":"sims/graph-viewer/#search","title":"Search","text":"<ul> <li>Type-ahead search for node names</li> <li>Displays matching results in a dropdown</li> <li>Shows node group/category in results</li> <li>Clicking a result focuses and highlights the node on the graph</li> <li>Only searches visible nodes (respects taxonomy filters)</li> </ul>"},{"location":"sims/graph-viewer/#taxonomy-legend-with-checkboxes","title":"Taxonomy Legend with Checkboxes","text":"<ul> <li>Sidebar legend with all node categories</li> <li>Toggle visibility of entire node groups</li> <li>Color-coded categories matching the graph</li> <li>\"Check All\" and \"Uncheck All\" buttons for bulk operations</li> <li>Collapsible sidebar to maximize graph viewing area</li> </ul>"},{"location":"sims/graph-viewer/#graph-statistics","title":"Graph Statistics","text":"<p>Real-time statistics that update as you filter: - Nodes: Count of visible nodes - Edges: Count of visible edges (both endpoints must be visible) - Orphans: Nodes with no connections (this is an indication that the learning graph needs editing)</p>"},{"location":"sims/graph-viewer/#sample-graph-demo","title":"Sample Graph Demo","text":"<p>The demo includes a Graph Theory learning graph with 10 taxonomy categories:</p> <ul> <li>Foundation (Red) - Core concepts in red boxes that should be pinned to the left</li> <li>Types (Orange) - Graph types</li> <li>Representations (Gold) - Data structures</li> <li>Algorithms (Green) - Basic algorithms</li> <li>Paths (Blue) - Shortest path algorithms</li> <li>Flow (Indigo) - Network flow algorithms</li> <li>Advanced (Violet) - Advanced topics</li> <li>Metrics (Gray) - Centrality measures</li> <li>Spectral (Brown) - Spectral theory</li> <li>ML &amp; Networks (Teal) - Machine learning</li> </ul>"},{"location":"sims/graph-viewer/#usage-tips","title":"Usage Tips","text":"<ol> <li>Hide a category - Uncheck a category in the sidebar to hide all nodes in that group</li> <li>Search within visible nodes - Use search to quickly find specific concepts among visible nodes</li> <li>Focus on a topic - Uncheck all categories, then check only the ones you want to study</li> <li>Collapse sidebar - Click the menu button (\u2630) to hide the sidebar and expand the graph view</li> <li>Find orphans - Check the statistics to see if any nodes lack connections</li> </ol>"},{"location":"sims/graph-viewer/#implementation-notes","title":"Implementation Notes","text":"<p>This viewer follows the standard vis.js architectural patterns:</p> <ul> <li>Uses <code>vis.DataSet</code> for nodes and edges</li> <li>Implements node <code>hidden</code> property for filtering</li> <li>Combines separate search and legend features</li> <li>Updates statistics dynamically based on visibility</li> <li>Maintains consistent styling across features</li> </ul>"},{"location":"sims/graph-viewer/#use-cases","title":"Use Cases","text":"<ul> <li>Course planning - Filter by topic area to design lesson sequences</li> <li>Concept exploration - Search for specific concepts and see their dependencies</li> <li>Gap analysis - Use orphan count to identify disconnected concepts</li> <li>Progressive learning - Start with foundation concepts, gradually enable advanced topics</li> </ul>"},{"location":"supplementary-content/claude-code-skills/","title":"Claude Code Skills","text":"<p>Claude Skills were announced by Anthropic on October 16, 2025.</p> <p>According to https://simonwillison.net/2025/Oct/16/claude-skills/, Skills are \"conceptually extremely simple: a skill is a Markdown file telling the model how to do something, optionally accompanied by extra documents and pre-written scripts that the model can run to help accomplish the tasks.\"</p> <p>Key details from the https://www.anthropic.com/news/skills: - Skills are modular, reusable task components - They work across Claude apps, Claude Code, and the API - Available on Pro, Max, Team, and Enterprise plans - Skills can include executable code for reliable task completion - Developers can install skills from the anthropics/skills marketplace</p> <p>Sources: - https://www.anthropic.com/news/skills - https://simonwillison.net/2025/Oct/16/claude-skills/ - https://www.infoq.com/news/2025/10/anthropic-claude-skills/</p>"},{"location":"supplementary-content/intelligent-textbook/","title":"Intelligent Textbooks: A Five-Level Framework","text":""},{"location":"supplementary-content/intelligent-textbook/#overview","title":"Overview","text":"<p>This Learning Linux course is designed as a Level 3 Intelligent Textbook\u2014an adaptive learning system that dynamically adjusts content based on individual learner performance. This page explains the intelligent textbook framework and how this course integrates with learning analytics systems.</p>"},{"location":"supplementary-content/intelligent-textbook/#the-five-levels-of-intelligent-textbooks","title":"The Five Levels of Intelligent Textbooks","text":"<p>The Five Levels of Intelligent Textbooks framework provides a standardized classification system for educational technology, inspired by the SAE J3016 autonomous vehicle standards. Each level represents increasing sophistication in personalization and AI integration.</p>"},{"location":"supplementary-content/intelligent-textbook/#level-1-static-textbooks","title":"Level 1: Static Textbooks","text":"<p>Traditional digital textbooks with fixed content and no interactivity. These are essentially PDF versions of printed books\u2014the content remains the same for every learner regardless of their progress or comprehension.</p> <p>Characteristics:</p> <ul> <li>Fixed, unchanging content</li> <li>No learner interaction tracking</li> <li>No personalization</li> <li>Minimal data collection requirements</li> </ul>"},{"location":"supplementary-content/intelligent-textbook/#level-2-interactive-textbooks","title":"Level 2: Interactive Textbooks","text":"<p>Textbooks incorporating multimedia, hyperlinks, and basic assessments. This level adds engagement through enriched media and quizzes but does not adapt to individual learners.</p> <p>Characteristics:</p> <ul> <li>Embedded videos, animations, and simulations (MicroSims)</li> <li>Hyperlinked navigation</li> <li>Basic quizzes and self-assessments</li> <li>Learning graphs as core data structures</li> <li>Limited learner data collection</li> </ul>"},{"location":"supplementary-content/intelligent-textbook/#level-3-adaptive-textbooks-this-course","title":"Level 3: Adaptive Textbooks (This Course)","text":"<p>Systems that dynamically adjust content based on individual learner performance, personalizing the educational experience in real time. This Learning Linux course operates at Level 3.</p> <p>Characteristics:</p> <ul> <li>Real-time content adaptation based on performance</li> <li>Personalized learning paths</li> <li>Progress tracking and analytics</li> <li>Integration with Learning Record Stores (LRS)</li> <li>Prerequisite-aware content sequencing</li> <li>Targeted remediation and enrichment</li> </ul> <p>Privacy Inflection Point</p> <p>Level 3 represents a critical privacy inflection point in the framework. Systems at this level and above require increasingly detailed individual learning histories, behavioral patterns, and performance data. This triggers regulatory compliance requirements under:</p> <ul> <li>FERPA (Family Educational Rights and Privacy Act) - US</li> <li>COPPA (Children's Online Privacy Protection Act) - US, for students under 13</li> <li>GDPR (General Data Protection Regulation) - European Union</li> </ul>"},{"location":"supplementary-content/intelligent-textbook/#level-4-chatbot-integrated-textbooks","title":"Level 4: Chatbot-Integrated Textbooks","text":"<p>Textbooks employing large language models for conversational tutoring, enabling dialogue-based learning support.</p> <p>Characteristics:</p> <ul> <li>Natural language Q&amp;A with AI tutors</li> <li>Conversational explanations of concepts</li> <li>On-demand help and clarification</li> <li>Conversation logs and interaction histories</li> <li>Increased data collection for personalization</li> </ul>"},{"location":"supplementary-content/intelligent-textbook/#level-5-autonomous-ai-textbooks","title":"Level 5: Autonomous AI Textbooks","text":"<p>Fully autonomous AI systems capable of comprehensive, real-time personalization across all learning contexts\u2014the educational equivalent of fully self-driving vehicles.</p> <p>Characteristics:</p> <ul> <li>Complete curriculum management by AI</li> <li>Cross-context learning adaptation</li> <li>Predictive learning path optimization</li> <li>Comprehensive behavioral modeling</li> <li>Maximum data requirements and privacy implications</li> </ul>"},{"location":"supplementary-content/intelligent-textbook/#learning-record-store-lrs-integration","title":"Learning Record Store (LRS) Integration","text":""},{"location":"supplementary-content/intelligent-textbook/#what-is-a-learning-record-store","title":"What is a Learning Record Store?","text":"<p>A Learning Record Store (LRS) is a specialized database that receives, stores, and returns learning activity statements using the xAPI (Experience API) standard. The LRS serves as the heart of any xAPI ecosystem, enabling:</p> <ul> <li>Cross-platform tracking: Capture learning activities from multiple sources\u2014web, mobile, simulations, and real-world activities</li> <li>Standardized data format: Use xAPI statements (Actor-Verb-Object) for consistent data representation</li> <li>Analytics and reporting: Generate insights from aggregated learning data</li> <li>Adaptive learning support: Provide data to intelligent systems that personalize content</li> </ul>"},{"location":"supplementary-content/intelligent-textbook/#xapi-statement-structure","title":"xAPI Statement Structure","text":"<p>Learning activities are recorded as xAPI statements following an Actor-Verb-Object pattern:</p> <pre><code>{\n  \"actor\": {\n    \"name\": \"Jane Doe\",\n    \"mbox\": \"mailto:jane@school.edu\"\n  },\n  \"verb\": {\n    \"id\": \"http://adlnet.gov/expapi/verbs/completed\",\n    \"display\": {\"en-US\": \"completed\"}\n  },\n  \"object\": {\n    \"id\": \"http://learning-linux.org/chapters/03-navigation\",\n    \"definition\": {\n      \"name\": {\"en-US\": \"Chapter 3: File System Navigation\"}\n    }\n  },\n  \"result\": {\n    \"score\": {\"scaled\": 0.85},\n    \"success\": true,\n    \"completion\": true\n  }\n}\n</code></pre>"},{"location":"supplementary-content/intelligent-textbook/#how-this-course-uses-lrs","title":"How This Course Uses LRS","text":"<p>The Learning Linux course can integrate with an LRS to track:</p> Activity Type Example xAPI Verbs Chapter completion <code>completed</code>, <code>progressed</code> Quiz performance <code>answered</code>, <code>passed</code>, <code>failed</code> MicroSim interactions <code>interacted</code>, <code>experienced</code> Terminal exercises <code>attempted</code>, <code>mastered</code> Time-on-task <code>initialized</code>, <code>terminated</code>"},{"location":"supplementary-content/intelligent-textbook/#available-lrs-options","title":"Available LRS Options","text":"<p>Schools implementing this course can choose from several LRS solutions:</p> LRS Type Cost Notes SQL LRS Open Source Free Self-hosted, Docker available Veracity SaaS/On-prem Free tier Moodle LTI integration Watershed Enterprise SaaS Free basic Advanced analytics paid Learning Pool Enterprise SaaS Paid Comprehensive tools"},{"location":"supplementary-content/intelligent-textbook/#privacy-and-compliance","title":"Privacy and Compliance","text":""},{"location":"supplementary-content/intelligent-textbook/#ferpa-compliance","title":"FERPA Compliance","text":"<p>For US educational institutions, FERPA requires:</p> <ul> <li>Student education records remain confidential</li> <li>Access limited to authorized personnel only</li> <li>Clear policies for record disclosure</li> <li>Third-party vendor contracts specifying data handling responsibilities</li> </ul>"},{"location":"supplementary-content/intelligent-textbook/#implementation-recommendations","title":"Implementation Recommendations","text":"<ol> <li>Authentication: Implement robust identity verification</li> <li>Encryption: Use encryption for data storage and transmission</li> <li>Access Control: Role-based permissions for viewing student data</li> <li>Data Retention: Clear policies on how long learning records are kept</li> <li>Vendor Review: Verify LRS vendor privacy policies and security measures</li> </ol> <p>Institutional Responsibility</p> <p>Schools deploying Level 3+ intelligent textbooks should work with their IT and legal departments to ensure proper data governance frameworks are in place before collecting detailed learning analytics.</p>"},{"location":"supplementary-content/intelligent-textbook/#why-level-3-for-this-course","title":"Why Level 3 for This Course?","text":"<p>The Learning Linux course implements Level 3 capabilities because:</p> <ol> <li> <p>Prerequisite Dependencies: Linux concepts build on each other\u2014file navigation before permissions, permissions before scripting. Adaptive sequencing ensures students master prerequisites.</p> </li> <li> <p>Skill Verification: Terminal commands require hands-on practice. Tracking actual command execution (not just reading) ensures competency.</p> </li> <li> <p>Personalized Pacing: High school students have varying backgrounds. Some need more time on fundamentals; others can accelerate.</p> </li> <li> <p>Instructor Visibility: Teachers need dashboards showing class progress, struggling students, and concept mastery rates.</p> </li> <li> <p>Actionable Analytics: Data-driven insights enable targeted interventions rather than one-size-fits-all instruction.</p> </li> </ol>"},{"location":"supplementary-content/intelligent-textbook/#economic-considerations","title":"Economic Considerations","text":"<p>Research indicates that by 2030, producing basic interactive content (Levels 1-2) will cost \"pennies per student per day,\" fundamentally disrupting traditional textbook economics. This means:</p> <ul> <li>Commodity content: Static and basic interactive materials become freely available</li> <li>Value migration: Competitive advantage shifts to personalization (Level 3+)</li> <li>Institutional strategy: Schools must prioritize adaptive learning to stay relevant</li> </ul> <p>The Learning Linux course embraces this reality by building Level 3 capabilities from the start, ensuring the content remains valuable as educational technology evolves.</p>"},{"location":"supplementary-content/intelligent-textbook/#references","title":"References","text":"<ul> <li>Intelligent Textbooks Project - Framework and research papers</li> <li>xAPI.com - Experience API specification and resources</li> <li>What is an LRS? - SCORM explanation of Learning Record Stores</li> <li>Valamis LRS Guide - Comprehensive LRS overview</li> <li>FERPA Compliance for LMS - Data privacy in educational systems</li> </ul>"},{"location":"supplementary-content/low-cost-raspberry-pd/","title":"Lowest-Cost Raspberry Pi Classroom Setup for Teaching Linux","text":"<p>Here's a budget breakdown for the most affordable classroom setup:</p> <p>Option 1: Ultra-Budget (Pi Zero 2 W) \u2014 ~$45-50/student</p> <p>| Component                                                                                  | Price (USD) |   |------------------------------------------------------------------------------------------------------------------   -------------------------------------------------------------------------------|-------------|   | https://www.raspberrypi.com/products/raspberry-pi-zero-2-w/                                                                                  | $15         |   | microSD Card (32GB)                                                                                  | $8-10       |   | USB Power Supply (5V micro-USB)                                                                                  | $8-10       |   | USB Keyboard + Mouse Combo (e.g., https://www.amazon.com/Computer-Keyboard-Mouse-Combos-Under-25/s?keywords=Compu   ter+Keyboard+%26+Mouse+Combos&amp;rh=n:1194464,p_36:1253503011&amp;c=ts&amp;ts_id=1194464) | $15-20      |   | USB OTG Hub (needed for Zero)                                                                                  | \\(5-8        |   | Total                                                                                  | ~\\)45-50     |</p> <p>Note: The Pi Zero 2 W requires a micro-USB OTG adapter/hub to connect keyboard/mouse, which adds complexity and   cost.</p> <p>Option 2: Recommended Budget (Pi 4 1GB) \u2014 ~$65-75/student</p> Component Price (USD) https://www.raspberrypi.com/products/ $35 microSD Card (32GB) $8-10 https://www.raspberrypi.com/products/type-c-power-supply/ $8-12 USB Keyboard + Mouse Combo $15-20 Total ~$65-75 <p>Why Pi 4 is Better for Classrooms:</p> <ul> <li>4 USB ports (no adapter needed)</li> <li>Dual monitor support</li> <li>Runs full desktop Linux smoothly</li> <li>Better for learning Python, VS Code, etc.</li> <li>Supports many educational kits</li> </ul> <p>Monitor Consideration</p> <p>Both options assume students use existing monitors/TVs with HDMI. If you need monitors, add $80-150 each.</p> <p>Bulk Discounts</p> <p>https://www.adafruit.com/educators for educators placing large orders.</p> <p>Bottom Line</p> <ul> <li>Absolute minimum: ~$45-50/student with Pi Zero 2 W</li> <li>Practical minimum: ~$65-75/student with Pi 4 (1GB) \u2014 recommended for a real Linux learning experience</li> </ul> <p>Sources:   - https://www.raspberrypi.com/products/raspberry-pi-zero-2-w/   - https://medium.com/engineering-iot/raspberry-pi-prices-in-2025-what-you-get-for-15-to-120-8f2e9b0b59d4   - https://www.tomshardware.com/best-picks/raspberry-pi-microsd-cards   - https://www.raspberrypi.com/products/type-c-power-supply/   - https://www.amazon.com/Computer-Keyboard-Mouse-Combos-Under-25/s?keywords=Computer+Keyboard+%26+Mouse+Combos&amp;rh=n   :1194464,p_36:1253503011&amp;c=ts&amp;ts_id=1194464</p>"},{"location":"supplementary-content/raspberry-pi-500-plus-impact/","title":"The Raspberry Pi 500+ Announcement: Impact on High School STEM Labs","text":"<p>## Overview of the Raspberry Pi 500+</p> <p>In September 2025, the Raspberry Pi Foundation   https://www.raspberrypi.com/news/the-ultimate-all-in-one-pc-raspberry-pi-500-plus-on-sale-now-at-200/, their   premium \"computer-in-a-keyboard\" desktop solution priced at \\(200 (\\)220 for the Desktop Kit). This builds on the   original Raspberry Pi 500 ($90) released earlier, offering substantial upgrades for more demanding educational and   professional use cases.</p> <p>## Specifications</p> Feature Raspberry Pi 500+ CPU 2.4GHz quad-core 64-bit Arm Cortex-A76 RAM 16GB LPDDR4X-4267 Storage 256GB NVMe SSD (internal M.2 slot) GPU VideoCore VII Keyboard Mechanical RGB (Gateron KS-33 Blue switches) Connectivity Dual-band Wi-Fi (802.11ac), Bluetooth 5.0/BLE, Gigabit Ethernet Ports 2x USB 3.0, 1x USB 2.0, Dual micro-HDMI (4K), 40-pin GPIO M.2 Support 2230, 2242, 2260, 2280 form factors Price $200 (unit) / $220 (Desktop Kit with mouse, PSU, cable, guide) <p>## Impact on High School STEM Labs</p> <p>### 1. Dramatic Cost Reduction</p> <p>Traditional computer labs cost $800-1,500+ per workstation. A 25-seat STEM lab comparison:</p> Setup Cost per Seat 25-Seat Lab Total Traditional PC $1,000-1,500 $25,000-37,500 Pi 500+ Desktop Kit $220 $5,500 Pi 500 Desktop Kit $120 $3,000 <p>Schools can deploy a https://opensource.com/article/18/3/computer-lab-school-raspberry-pi using Raspberry Pi   devices\u2014a fraction of traditional costs.</p> <p>### 2. Real Computing Power for Modern Curriculum</p> <p>The Pi 500+ is no longer a \"toy\" computer:   - 16GB RAM handles VS Code, multiple browser tabs, and development environments   - 256GB NVMe SSD provides fast boot times and ample storage for projects   - Dual 4K display support enables professional-grade visual work   - Runs full Raspberry Pi OS (Debian-based Linux), Python, Scratch, and web development tools</p> <p>This makes it suitable for teaching:   - Linux system administration   - Python programming   - Web development (HTML/CSS/JS, Node.js)   - Data science basics   - Robotics and physical computing (GPIO pins)</p> <p>### 3. Physical Computing Integration</p> <p>Unlike traditional PCs, the Pi 500+ retains the 40-pin GPIO header, enabling direct integration with:   - Sensors and actuators   - Robotics projects   - IoT experimentation   - Electronics prototyping</p> <p>Students learn both software AND hardware\u2014a unique advantage for STEM education.</p> <p>### 4. Durability and Maintenance</p> <ul> <li>Solid-state design with no moving parts (fanless operation)</li> <li>Lower power consumption (~15-27W vs. 200-500W for traditional PCs)</li> <li>Simple recovery\u2014reflash the SD card or reinstall on NVMe</li> <li>Reduced IT burden\u2014standardized, reproducible setups</li> </ul> <p>### 5. Considerations and Trade-offs</p> <p>According to https://www.tomshardware.com/raspberry-pi/raspberry-pi-500-plus-review, at $200, some may compare it   to budget laptops or Intel N100 mini PCs. However, the Pi 500+ offers:   - A complete keyboard-computer solution (no separate case/keyboard needed)   - GPIO for physical computing (unique advantage)   - Strong educational ecosystem and curriculum support   - Community and foundation resources</p> <p>Recommended Configurations for Schools</p> Use Case Model Per-Seat Cost Basic Linux/coding intro Pi 500 ($90) + monitor ~$170-250 Full STEM curriculum Pi 500+ ($220) + monitor ~$300-400 Budget-constrained Pi 4 (1GB) + peripherals ~$120-150 <p>## Conclusion</p> <p>The Raspberry Pi 500+ represents a significant milestone for affordable STEM education. At $200-220, schools can   deploy high-quality, capable Linux workstations that teach real-world skills\u2014from command-line proficiency to   physical computing\u2014at roughly 1/5 to 1/7 the cost of traditional PC labs. The inclusion of 16GB RAM, NVMe storage,   and mechanical keyboard transforms what was once a hobbyist device into a legitimate educational computing   platform.</p> <p>For high schools looking to expand STEM offerings without massive capital investment, the Pi 500 family offers an   unprecedented opportunity to democratize access to computing education.</p> <p>## Sources:   - https://www.raspberrypi.com/news/the-ultimate-all-in-one-pc-raspberry-pi-500-plus-on-sale-now-at-200/   - https://www.tomshardware.com/raspberry-pi/raspberry-pi-500-plus-review   - https://raspberrytips.com/raspberry-pi-500-plus-announced/   - https://opensource.com/article/18/3/computer-lab-school-raspberry-pi   - https://pidora.ca/transform-your-classroom-how-raspberry-pi-makes-stem-learning-come-alive/   - https://www.digikey.com/en/maker/blogs/2025/raspberry-pi-500-launches-with-256gb-nvme-ssd-and-16gb-ram</p>"}]}